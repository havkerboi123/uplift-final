{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///D:/uplift-demo/demo/node_modules/livekit-server-sdk/src/grants.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { RoomConfiguration } from '@livekit/protocol';\nimport { TrackSource } from '@livekit/protocol';\nimport type { JWTPayload } from 'jose';\n\nexport function trackSourceToString(source: TrackSource) {\n  switch (source) {\n    case TrackSource.CAMERA:\n      return 'camera';\n    case TrackSource.MICROPHONE:\n      return 'microphone';\n    case TrackSource.SCREEN_SHARE:\n      return 'screen_share';\n    case TrackSource.SCREEN_SHARE_AUDIO:\n      return 'screen_share_audio';\n    default:\n      throw new TypeError(`Cannot convert TrackSource ${source} to string`);\n  }\n}\n\nexport function claimsToJwtPayload(\n  grant: ClaimGrants,\n): JWTPayload & { video?: Record<string, unknown> } {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const claim: Record<string, any> = { ...grant };\n  // eslint-disable-next-line no-restricted-syntax\n  if (Array.isArray(claim.video?.canPublishSources)) {\n    claim.video.canPublishSources = claim.video.canPublishSources.map(trackSourceToString);\n  }\n  return claim;\n}\n\nexport interface VideoGrant {\n  /** permission to create a room */\n  roomCreate?: boolean;\n\n  /** permission to join a room as a participant, room must be set */\n  roomJoin?: boolean;\n\n  /** permission to list rooms */\n  roomList?: boolean;\n\n  /** permission to start a recording */\n  roomRecord?: boolean;\n\n  /** permission to control a specific room, room must be set */\n  roomAdmin?: boolean;\n\n  /** name of the room, must be set for admin or join permissions */\n  room?: string;\n\n  /** permissions to control ingress, not specific to any room or ingress */\n  ingressAdmin?: boolean;\n\n  /**\n   * allow participant to publish. If neither canPublish or canSubscribe is set,\n   * both publish and subscribe are enabled\n   */\n  canPublish?: boolean;\n\n  /**\n   * TrackSource types that the participant is allowed to publish\n   * When set, it supersedes CanPublish. Only sources explicitly set here can be published\n   */\n  canPublishSources?: TrackSource[];\n\n  /** allow participant to subscribe to other tracks */\n  canSubscribe?: boolean;\n\n  /**\n   * allow participants to publish data, defaults to true if not set\n   */\n  canPublishData?: boolean;\n\n  /**\n   * by default, a participant is not allowed to update its own metadata\n   */\n  canUpdateOwnMetadata?: boolean;\n\n  /** participant isn't visible to others */\n  hidden?: boolean;\n\n  /** participant is recording the room, when set, allows room to indicate it's being recorded */\n  recorder?: boolean;\n\n  /** participant allowed to connect to LiveKit as Agent Framework worker */\n  agent?: boolean;\n\n  /** allow participant to subscribe to metrics */\n  canSubscribeMetrics?: boolean;\n\n  /** destination room which this participant can forward to */\n  destinationRoom?: string;\n}\n\nexport interface SIPGrant {\n  /** manage sip resources */\n  admin?: boolean;\n\n  /** make outbound calls */\n  call?: boolean;\n}\n\nexport interface InferenceGrant {\n  /** perform inference */\n  perform?: boolean;\n}\n\n/** @internal */\nexport interface ClaimGrants extends JWTPayload {\n  name?: string;\n  video?: VideoGrant;\n  sip?: SIPGrant;\n  inference?: InferenceGrant;\n  kind?: string;\n  metadata?: string;\n  attributes?: Record<string, string>;\n  sha256?: string;\n  roomPreset?: string;\n  roomConfig?: RoomConfiguration;\n}\n"],"names":[],"mappings":";;;;;;AAIA,SAAS,mBAAmB;;AAGrB,SAAS,oBAAoB,MAAA,EAAqB;IACvD,OAAQ,QAAQ;QACd,KAAK,wLAAA,CAAY,MAAA;YACf,OAAO;QACT,KAAK,wLAAA,CAAY,UAAA;YACf,OAAO;QACT,KAAK,wLAAA,CAAY,YAAA;YACf,OAAO;QACT,KAAK,wLAAA,CAAY,kBAAA;YACf,OAAO;QACT;YACE,MAAM,IAAI,UAAU,CAAA,2BAAA,EAA8B,MAAM,CAAA,UAAA,CAAY;IACxE;AACF;AAEO,SAAS,mBACd,KAAA,EACkD;IAxBpD,IAAA;IA0BE,MAAM,QAA6B;QAAE,GAAG,KAAA;IAAM;IAE9C,IAAI,MAAM,OAAA,CAAA,CAAQ,KAAA,MAAM,KAAA,KAAN,OAAA,KAAA,IAAA,GAAa,iBAAiB,GAAG;QACjD,MAAM,KAAA,CAAM,iBAAA,GAAoB,MAAM,KAAA,CAAM,iBAAA,CAAkB,GAAA,CAAI,mBAAmB;IACvF;IACA,OAAO;AACT","debugId":null}},
    {"offset": {"line": 42, "column": 0}, "map": {"version":3,"sources":["file:///D:/uplift-demo/demo/node_modules/livekit-server-sdk/src/AccessToken.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { RoomConfiguration } from '@livekit/protocol';\nimport * as jose from 'jose';\nimport type { ClaimGrants, InferenceGrant, SIPGrant, VideoGrant } from './grants.js';\nimport { claimsToJwtPayload } from './grants.js';\n\n// 6 hours\nconst defaultTTL = `6h`;\n\nconst defaultClockToleranceSeconds = 10;\n\nexport interface AccessTokenOptions {\n  /**\n   * amount of time before expiration\n   * expressed in seconds or a string describing a time span zeit/ms.\n   * eg: '2 days', '10h', or seconds as numeric value\n   */\n  ttl?: number | string;\n\n  /**\n   * display name for the participant, available as `Participant.name`\n   */\n  name?: string;\n\n  /**\n   * identity of the user, required for room join tokens\n   */\n  identity?: string;\n\n  /**\n   * custom participant metadata\n   */\n  metadata?: string;\n\n  /**\n   * custom participant attributes\n   */\n  attributes?: Record<string, string>;\n}\n\nexport class AccessToken {\n  private apiKey: string;\n\n  private apiSecret: string;\n\n  private grants: ClaimGrants;\n\n  identity?: string;\n\n  ttl: number | string;\n\n  /**\n   * Creates a new AccessToken\n   * @param apiKey - API Key, can be set in env LIVEKIT_API_KEY\n   * @param apiSecret - Secret, can be set in env LIVEKIT_API_SECRET\n   */\n  constructor(apiKey?: string, apiSecret?: string, options?: AccessTokenOptions) {\n    if (!apiKey) {\n      apiKey = process.env.LIVEKIT_API_KEY;\n    }\n    if (!apiSecret) {\n      apiSecret = process.env.LIVEKIT_API_SECRET;\n    }\n    if (!apiKey || !apiSecret) {\n      throw Error('api-key and api-secret must be set');\n    }\n    // @ts-expect-error we're not including dom lib for the server sdk so document is not defined\n    else if (typeof document !== 'undefined') {\n      // check against document rather than window because deno provides window\n      console.error(\n        'You should not include your API secret in your web client bundle.\\n\\n' +\n          'Your web client should request a token from your backend server which should then use ' +\n          'the API secret to generate a token. See https://docs.livekit.io/client/connect/',\n      );\n    }\n    this.apiKey = apiKey;\n    this.apiSecret = apiSecret;\n    this.grants = {};\n    this.identity = options?.identity;\n    this.ttl = options?.ttl || defaultTTL;\n    if (typeof this.ttl === 'number') {\n      this.ttl = `${this.ttl}s`;\n    }\n    if (options?.metadata) {\n      this.metadata = options.metadata;\n    }\n    if (options?.attributes) {\n      this.attributes = options.attributes;\n    }\n    if (options?.name) {\n      this.name = options.name;\n    }\n  }\n\n  /**\n   * Adds a video grant to this token.\n   * @param grant -\n   */\n  addGrant(grant: VideoGrant) {\n    this.grants.video = { ...(this.grants.video ?? {}), ...grant };\n  }\n\n  /**\n   * Adds an inference grant to this token.\n   * @param grant -\n   */\n  addInferenceGrant(grant: InferenceGrant) {\n    this.grants.inference = { ...(this.grants.inference ?? {}), ...grant };\n  }\n\n  /**\n   * Adds a SIP grant to this token.\n   * @param grant -\n   */\n  addSIPGrant(grant: SIPGrant) {\n    this.grants.sip = { ...(this.grants.sip ?? {}), ...grant };\n  }\n\n  get name(): string | undefined {\n    return this.grants.name;\n  }\n\n  set name(name: string) {\n    this.grants.name = name;\n  }\n\n  get metadata(): string | undefined {\n    return this.grants.metadata;\n  }\n\n  /**\n   * Set metadata to be passed to the Participant, used only when joining the room\n   */\n  set metadata(md: string) {\n    this.grants.metadata = md;\n  }\n\n  get attributes(): Record<string, string> | undefined {\n    return this.grants.attributes;\n  }\n\n  set attributes(attrs: Record<string, string>) {\n    this.grants.attributes = attrs;\n  }\n\n  get kind(): string | undefined {\n    return this.grants.kind;\n  }\n\n  set kind(kind: string) {\n    this.grants.kind = kind;\n  }\n\n  get sha256(): string | undefined {\n    return this.grants.sha256;\n  }\n\n  set sha256(sha: string | undefined) {\n    this.grants.sha256 = sha;\n  }\n\n  get roomPreset(): string | undefined {\n    return this.grants.roomPreset;\n  }\n\n  set roomPreset(preset: string | undefined) {\n    this.grants.roomPreset = preset;\n  }\n\n  get roomConfig(): RoomConfiguration | undefined {\n    return this.grants.roomConfig;\n  }\n\n  set roomConfig(config: RoomConfiguration | undefined) {\n    this.grants.roomConfig = config;\n  }\n\n  /**\n   * @returns JWT encoded token\n   */\n  async toJwt(): Promise<string> {\n    // TODO: check for video grant validity\n\n    const secret = new TextEncoder().encode(this.apiSecret);\n\n    const jwt = new jose.SignJWT(claimsToJwtPayload(this.grants))\n      .setProtectedHeader({ alg: 'HS256' })\n      .setIssuer(this.apiKey)\n      .setExpirationTime(this.ttl)\n      .setNotBefore(0);\n    if (this.identity) {\n      jwt.setSubject(this.identity);\n    } else if (this.grants.video?.roomJoin) {\n      throw Error('identity is required for join but not set');\n    }\n    return jwt.sign(secret);\n  }\n}\n\nexport class TokenVerifier {\n  private apiKey: string;\n\n  private apiSecret: string;\n\n  constructor(apiKey: string, apiSecret: string) {\n    this.apiKey = apiKey;\n    this.apiSecret = apiSecret;\n  }\n\n  async verify(\n    token: string,\n    clockTolerance: string | number = defaultClockToleranceSeconds,\n  ): Promise<ClaimGrants> {\n    const secret = new TextEncoder().encode(this.apiSecret);\n    const { payload } = await jose.jwtVerify(token, secret, {\n      issuer: this.apiKey,\n      clockTolerance,\n    });\n    if (!payload) {\n      throw Error('invalid token');\n    }\n\n    return payload as ClaimGrants;\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 200, "column": 0}, "map": {"version":3,"sources":["file:///D:/uplift-demo/demo/node_modules/livekit-server-sdk/src/ServiceBase.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport { AccessToken } from './AccessToken.js';\nimport type { SIPGrant, VideoGrant } from './grants.js';\n\n/**\n * Utilities to handle authentication\n */\nexport class ServiceBase {\n  private readonly apiKey?: string;\n\n  private readonly secret?: string;\n\n  private readonly ttl: string;\n\n  /**\n   * @param apiKey - API Key.\n   * @param secret - API Secret.\n   * @param ttl - token TTL\n   */\n  constructor(apiKey?: string, secret?: string, ttl?: string) {\n    this.apiKey = apiKey;\n    this.secret = secret;\n    this.ttl = ttl || '10m';\n  }\n\n  async authHeader(grant: VideoGrant, sip?: SIPGrant): Promise<Record<string, string>> {\n    const at = new AccessToken(this.apiKey, this.secret, { ttl: this.ttl });\n    if (grant) {\n      at.addGrant(grant);\n    }\n    if (sip) {\n      at.addSIPGrant(sip);\n    }\n    return {\n      Authorization: `Bearer ${await at.toJwt()}`,\n    };\n  }\n}\n"],"names":[],"mappings":";;;;AAGA,SAAS,mBAAmB;;AAMrB,MAAM,YAAY;IAAA;;;;GAAA,GAYvB,YAAY,MAAA,EAAiB,MAAA,EAAiB,GAAA,CAAc;QAC1D,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,GAAA,GAAM,OAAO;IACpB;IAEA,MAAM,WAAW,KAAA,EAAmB,GAAA,EAAiD;QACnF,MAAM,KAAK,IAAI,gLAAA,CAAY,IAAA,CAAK,MAAA,EAAQ,IAAA,CAAK,MAAA,EAAQ;YAAE,KAAK,IAAA,CAAK,GAAA;QAAI,CAAC;QACtE,IAAI,OAAO;YACT,GAAG,QAAA,CAAS,KAAK;QACnB;QACA,IAAI,KAAK;YACP,GAAG,WAAA,CAAY,GAAG;QACpB;QACA,OAAO;YACL,eAAe,CAAA,OAAA,EAAU,MAAM,GAAG,KAAA,CAAM,CAAC,EAAA;QAC3C;IACF;AACF","debugId":null}},
    {"offset": {"line": 237, "column": 0}, "map": {"version":3,"sources":["file:///D:/uplift-demo/demo/node_modules/livekit-server-sdk/src/TwirpRPC.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { JsonValue } from '@bufbuild/protobuf';\n\n// twirp RPC adapter for client implementation\n\nconst defaultPrefix = '/twirp';\n\nexport const livekitPackage = 'livekit';\nexport interface Rpc {\n  request(\n    service: string,\n    method: string,\n    data: JsonValue,\n    headers: any, // eslint-disable-line @typescript-eslint/no-explicit-any\n    timeout?: number,\n  ): Promise<string>;\n}\n\nexport class TwirpError extends Error {\n  status: number;\n  code?: string;\n  metadata?: Record<string, string>;\n\n  constructor(\n    name: string,\n    message: string,\n    status: number,\n    code?: string,\n    metadata?: Record<string, string>,\n  ) {\n    super(message);\n    this.name = name;\n    this.status = status;\n    this.code = code;\n    this.metadata = metadata;\n  }\n}\n\n/**\n * JSON based Twirp V7 RPC\n */\nexport class TwirpRpc {\n  host: string;\n\n  pkg: string;\n\n  prefix: string;\n\n  constructor(host: string, pkg: string, prefix?: string) {\n    if (host.startsWith('ws')) {\n      host = host.replace('ws', 'http');\n    }\n    this.host = host;\n    this.pkg = pkg;\n    this.prefix = prefix || defaultPrefix;\n  }\n\n  async request(\n    service: string,\n    method: string,\n    data: any, // eslint-disable-line @typescript-eslint/no-explicit-any\n    headers: any, // eslint-disable-line @typescript-eslint/no-explicit-any\n    timeout = 60,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Promise<any> {\n    const path = `${this.prefix}/${this.pkg}.${service}/${method}`;\n    const url = new URL(path, this.host);\n    const init: RequestInit = {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json;charset=UTF-8',\n        ...headers,\n      },\n      body: JSON.stringify(data),\n    };\n\n    if (timeout) {\n      init.signal = AbortSignal.timeout(timeout * 1000);\n    }\n\n    const response = await fetch(url, init);\n\n    if (!response.ok) {\n      const isJson = response.headers.get('content-type') === 'application/json';\n      let errorMessage = 'Unknown internal error';\n      let errorCode: string | undefined = undefined;\n      let metadata: Record<string, string> | undefined = undefined;\n      try {\n        if (isJson) {\n          const parsedError = (await response.json()) as Record<string, unknown>;\n          if ('msg' in parsedError) {\n            errorMessage = <string>parsedError.msg;\n          }\n          if ('code' in parsedError) {\n            errorCode = <string>parsedError.code;\n          }\n          if ('meta' in parsedError) {\n            metadata = <Record<string, string>>parsedError.meta;\n          }\n        } else {\n          errorMessage = await response.text();\n        }\n      } catch (e) {\n        // parsing went wrong, no op and we keep default error message\n        console.debug(`Error when trying to parse error message, using defaults`, e);\n      }\n\n      throw new TwirpError(response.statusText, errorMessage, response.status, errorCode, metadata);\n    }\n    const parsedResp = (await response.json()) as Record<string, unknown>;\n\n    const camelcaseKeys = await import('camelcase-keys').then((mod) => mod.default);\n    return camelcaseKeys(parsedResp, { deep: true });\n  }\n}\n"],"names":[],"mappings":";;;;;;;;AAOA,MAAM,gBAAgB;AAEf,MAAM,iBAAiB;AAWvB,MAAM,mBAAmB,MAAM;IAKpC,YACE,IAAA,EACA,OAAA,EACA,MAAA,EACA,IAAA,EACA,QAAA,CACA;QACA,KAAA,CAAM,OAAO;QACb,IAAA,CAAK,IAAA,GAAO;QACZ,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO;QACZ,IAAA,CAAK,QAAA,GAAW;IAClB;AACF;AAKO,MAAM,SAAS;IAOpB,YAAY,IAAA,EAAc,GAAA,EAAa,MAAA,CAAiB;QACtD,IAAI,KAAK,UAAA,CAAW,IAAI,GAAG;YACzB,OAAO,KAAK,OAAA,CAAQ,MAAM,MAAM;QAClC;QACA,IAAA,CAAK,IAAA,GAAO;QACZ,IAAA,CAAK,GAAA,GAAM;QACX,IAAA,CAAK,MAAA,GAAS,UAAU;IAC1B;IAEA,MAAM,QACJ,OAAA,EACA,MAAA,EACA,IAAA,EACA,OAAA,EACA,UAAU,EAAA,EAEI;QACd,MAAM,OAAO,GAAG,IAAA,CAAK,MAAM,CAAA,CAAA,EAAI,IAAA,CAAK,GAAG,CAAA,CAAA,EAAI,OAAO,CAAA,CAAA,EAAI,MAAM,EAAA;QAC5D,MAAM,MAAM,IAAI,IAAI,MAAM,IAAA,CAAK,IAAI;QACnC,MAAM,OAAoB;YACxB,QAAQ;YACR,SAAS;gBACP,gBAAgB;gBAChB,GAAG,OAAA;YACL;YACA,MAAM,KAAK,SAAA,CAAU,IAAI;QAC3B;QAEA,IAAI,SAAS;YACX,KAAK,MAAA,GAAS,YAAY,OAAA,CAAQ,UAAU,GAAI;QAClD;QAEA,MAAM,WAAW,MAAM,MAAM,KAAK,IAAI;QAEtC,IAAI,CAAC,SAAS,EAAA,EAAI;YAChB,MAAM,SAAS,SAAS,OAAA,CAAQ,GAAA,CAAI,cAAc,MAAM;YACxD,IAAI,eAAe;YACnB,IAAI,YAAgC,KAAA;YACpC,IAAI,WAA+C,KAAA;YACnD,IAAI;gBACF,IAAI,QAAQ;oBACV,MAAM,cAAe,MAAM,SAAS,IAAA,CAAK;oBACzC,IAAI,SAAS,aAAa;wBACxB,eAAuB,YAAY,GAAA;oBACrC;oBACA,IAAI,UAAU,aAAa;wBACzB,YAAoB,YAAY,IAAA;oBAClC;oBACA,IAAI,UAAU,aAAa;wBACzB,WAAmC,YAAY,IAAA;oBACjD;gBACF,OAAO;oBACL,eAAe,MAAM,SAAS,IAAA,CAAK;gBACrC;YACF,EAAA,OAAS,GAAG;gBAEV,QAAQ,KAAA,CAAM,CAAA,wDAAA,CAAA,EAA4D,CAAC;YAC7E;YAEA,MAAM,IAAI,WAAW,SAAS,UAAA,EAAY,cAAc,SAAS,MAAA,EAAQ,WAAW,QAAQ;QAC9F;QACA,MAAM,aAAc,MAAM,SAAS,IAAA,CAAK;QAExC,MAAM,gBAAgB,MAAM,OAAO,gBAAgB,0FAAE,IAAA,CAAK,CAAC,MAAQ,IAAI,OAAO;QAC9E,OAAO,cAAc,YAAY;YAAE,MAAM;QAAK,CAAC;IACjD;AACF","debugId":null}},
    {"offset": {"line": 318, "column": 0}, "map": {"version":3,"sources":["file:///D:/uplift-demo/demo/node_modules/livekit-server-sdk/src/AgentDispatchClient.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport {\n  AgentDispatch,\n  CreateAgentDispatchRequest,\n  DeleteAgentDispatchRequest,\n  ListAgentDispatchRequest,\n  ListAgentDispatchResponse,\n} from '@livekit/protocol';\nimport { ServiceBase } from './ServiceBase.js';\nimport { type Rpc, TwirpRpc, livekitPackage } from './TwirpRPC.js';\n\ninterface CreateDispatchOptions {\n  // any custom data to send along with the job.\n  // note: this is different from room and participant metadata\n  metadata?: string;\n}\n\nconst svc = 'AgentDispatchService';\n\n/**\n * Client to access Agent APIs\n */\nexport class AgentDispatchClient extends ServiceBase {\n  private readonly rpc: Rpc;\n\n  /**\n   * @param host - hostname including protocol. i.e. 'https://<project>.livekit.cloud'\n   * @param apiKey - API Key, can be set in env var LIVEKIT_API_KEY\n   * @param secret - API Secret, can be set in env var LIVEKIT_API_SECRET\n   */\n  constructor(host: string, apiKey?: string, secret?: string) {\n    super(apiKey, secret);\n    this.rpc = new TwirpRpc(host, livekitPackage);\n  }\n\n  /**\n   * Create an explicit dispatch for an agent to join a room. To use explicit\n   * dispatch, your agent must be registered with an `agentName`.\n   * @param roomName - name of the room to dispatch to\n   * @param agentName - name of the agent to dispatch\n   * @param options - optional metadata to send along with the dispatch\n   * @returns the dispatch that was created\n   */\n  async createDispatch(\n    roomName: string,\n    agentName: string,\n    options?: CreateDispatchOptions,\n  ): Promise<AgentDispatch> {\n    const req = new CreateAgentDispatchRequest({\n      room: roomName,\n      agentName,\n      metadata: options?.metadata,\n    }).toJson();\n    const data = await this.rpc.request(\n      svc,\n      'CreateDispatch',\n      req,\n      await this.authHeader({ roomAdmin: true, room: roomName }),\n    );\n    return AgentDispatch.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * Delete an explicit dispatch for an agent in a room.\n   * @param dispatchId - id of the dispatch to delete\n   * @param roomName - name of the room the dispatch is for\n   */\n  async deleteDispatch(dispatchId: string, roomName: string): Promise<void> {\n    const req = new DeleteAgentDispatchRequest({\n      dispatchId,\n      room: roomName,\n    }).toJson();\n    await this.rpc.request(\n      svc,\n      'DeleteDispatch',\n      req,\n      await this.authHeader({ roomAdmin: true, room: roomName }),\n    );\n  }\n\n  /**\n   * Get an Agent dispatch by ID\n   * @param dispatchId - id of the dispatch to get\n   * @param roomName - name of the room the dispatch is for\n   * @returns the dispatch that was found, or undefined if not found\n   */\n  async getDispatch(dispatchId: string, roomName: string): Promise<AgentDispatch | undefined> {\n    const req = new ListAgentDispatchRequest({\n      dispatchId,\n      room: roomName,\n    }).toJson();\n    const data = await this.rpc.request(\n      svc,\n      'ListDispatch',\n      req,\n      await this.authHeader({ roomAdmin: true, room: roomName }),\n    );\n    const res = ListAgentDispatchResponse.fromJson(data, { ignoreUnknownFields: true });\n    if (res.agentDispatches.length === 0) {\n      return undefined;\n    }\n    return res.agentDispatches[0];\n  }\n\n  /**\n   * List all agent dispatches for a room\n   * @param roomName - name of the room to list dispatches for\n   * @returns the list of dispatches\n   */\n  async listDispatch(roomName: string): Promise<AgentDispatch[]> {\n    const req = new ListAgentDispatchRequest({\n      room: roomName,\n    }).toJson();\n    const data = await this.rpc.request(\n      svc,\n      'ListDispatch',\n      req,\n      await this.authHeader({ roomAdmin: true, room: roomName }),\n    );\n    const res = ListAgentDispatchResponse.fromJson(data, { ignoreUnknownFields: true });\n    return res.agentDispatches;\n  }\n}\n"],"names":[],"mappings":";;;;AAGA;AAOA,SAAS,mBAAmB;AAC5B,SAAmB,UAAU,sBAAsB;;;;AAQnD,MAAM,MAAM;AAKL,MAAM,4BAA4B,gLAAA,CAAY;IAAA;;;;GAAA,GAQnD,YAAY,IAAA,EAAc,MAAA,EAAiB,MAAA,CAAiB;QAC1D,KAAA,CAAM,QAAQ,MAAM;QACpB,IAAA,CAAK,GAAA,GAAM,IAAI,0KAAA,CAAS,MAAM,gLAAc;IAC9C;IAAA;;;;;;;GAAA,GAUA,MAAM,eACJ,QAAA,EACA,SAAA,EACA,OAAA,EACwB;QACxB,MAAM,MAAM,IAAI,uMAAA,CAA2B;YACzC,MAAM;YACN;YACA,UAAU,WAAA,OAAA,KAAA,IAAA,QAAS,QAAA;QACrB,CAAC,EAAE,MAAA,CAAO;QACV,MAAM,OAAO,MAAM,IAAA,CAAK,GAAA,CAAI,OAAA,CAC1B,KACA,kBACA,KACA,MAAM,IAAA,CAAK,UAAA,CAAW;YAAE,WAAW;YAAM,MAAM;QAAS,CAAC;QAE3D,OAAO,0LAAA,CAAc,QAAA,CAAS,MAAM;YAAE,qBAAqB;QAAK,CAAC;IACnE;IAAA;;;;GAAA,GAOA,MAAM,eAAe,UAAA,EAAoB,QAAA,EAAiC;QACxE,MAAM,MAAM,IAAI,uMAAA,CAA2B;YACzC;YACA,MAAM;QACR,CAAC,EAAE,MAAA,CAAO;QACV,MAAM,IAAA,CAAK,GAAA,CAAI,OAAA,CACb,KACA,kBACA,KACA,MAAM,IAAA,CAAK,UAAA,CAAW;YAAE,WAAW;YAAM,MAAM;QAAS,CAAC;IAE7D;IAAA;;;;;GAAA,GAQA,MAAM,YAAY,UAAA,EAAoB,QAAA,EAAsD;QAC1F,MAAM,MAAM,IAAI,qMAAA,CAAyB;YACvC;YACA,MAAM;QACR,CAAC,EAAE,MAAA,CAAO;QACV,MAAM,OAAO,MAAM,IAAA,CAAK,GAAA,CAAI,OAAA,CAC1B,KACA,gBACA,KACA,MAAM,IAAA,CAAK,UAAA,CAAW;YAAE,WAAW;YAAM,MAAM;QAAS,CAAC;QAE3D,MAAM,MAAM,sMAAA,CAA0B,QAAA,CAAS,MAAM;YAAE,qBAAqB;QAAK,CAAC;QAClF,IAAI,IAAI,eAAA,CAAgB,MAAA,KAAW,GAAG;YACpC,OAAO,KAAA;QACT;QACA,OAAO,IAAI,eAAA,CAAgB,CAAC,CAAA;IAC9B;IAAA;;;;GAAA,GAOA,MAAM,aAAa,QAAA,EAA4C;QAC7D,MAAM,MAAM,IAAI,qMAAA,CAAyB;YACvC,MAAM;QACR,CAAC,EAAE,MAAA,CAAO;QACV,MAAM,OAAO,MAAM,IAAA,CAAK,GAAA,CAAI,OAAA,CAC1B,KACA,gBACA,KACA,MAAM,IAAA,CAAK,UAAA,CAAW;YAAE,WAAW;YAAM,MAAM;QAAS,CAAC;QAE3D,MAAM,MAAM,sMAAA,CAA0B,QAAA,CAAS,MAAM;YAAE,qBAAqB;QAAK,CAAC;QAClF,OAAO,IAAI,eAAA;IACb;AACF","debugId":null}},
    {"offset": {"line": 419, "column": 0}, "map": {"version":3,"sources":["file:///D:/uplift-demo/demo/node_modules/livekit-server-sdk/src/EgressClient.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type {\n  DirectFileOutput,\n  EncodedFileOutput,\n  EncodingOptions,\n  EncodingOptionsPreset,\n  ImageOutput,\n  SegmentedFileOutput,\n  StreamOutput,\n  WebhookConfig,\n} from '@livekit/protocol';\nimport {\n  AudioMixing,\n  EgressInfo,\n  ListEgressRequest,\n  ListEgressResponse,\n  ParticipantEgressRequest,\n  RoomCompositeEgressRequest,\n  StopEgressRequest,\n  TrackCompositeEgressRequest,\n  TrackEgressRequest,\n  UpdateLayoutRequest,\n  UpdateStreamRequest,\n  WebEgressRequest,\n} from '@livekit/protocol';\nimport { ServiceBase } from './ServiceBase.js';\nimport type { Rpc } from './TwirpRPC.js';\nimport { TwirpRpc, livekitPackage } from './TwirpRPC.js';\n\nconst svc = 'Egress';\n\nexport interface BaseOptions {\n  /**\n   * webhooks to call for this request, optional.\n   */\n  webhooks?: WebhookConfig[];\n}\n\nexport interface RoomCompositeOptions extends BaseOptions {\n  /**\n   * egress layout. optional\n   */\n  layout?: string;\n  /**\n   * encoding options or preset. optional\n   */\n  encodingOptions?: EncodingOptionsPreset | EncodingOptions;\n  /**\n   * record audio only. optional\n   */\n  audioOnly?: boolean;\n  /**\n   * record video only. optional\n   */\n  videoOnly?: boolean;\n  /**\n   * custom template url. optional\n   */\n  customBaseUrl?: string;\n  /**\n   * audio mixing options. optional\n   */\n  audioMixing?: AudioMixing;\n}\n\nexport interface WebOptions extends BaseOptions {\n  /**\n   * encoding options or preset. optional\n   */\n  encodingOptions?: EncodingOptionsPreset | EncodingOptions;\n  /**\n   * record audio only. optional\n   */\n  audioOnly?: boolean;\n  /**\n   * record video only. optional\n   */\n  videoOnly?: boolean;\n  /**\n   * await START_RECORDING chrome log\n   */\n  awaitStartSignal?: boolean;\n}\n\nexport interface ParticipantEgressOptions extends BaseOptions {\n  /**\n   * true to capture source screenshare and screenshare_audio\n   * false to capture camera and microphone\n   */\n  screenShare?: boolean;\n  /**\n   * encoding options or preset. optional\n   */\n  encodingOptions?: EncodingOptionsPreset | EncodingOptions;\n}\n\nexport interface TrackCompositeOptions extends BaseOptions {\n  /**\n   * audio track ID\n   */\n  audioTrackId?: string;\n  /**\n   * video track ID\n   */\n  videoTrackId?: string;\n  /**\n   * encoding options or preset. optional\n   */\n  encodingOptions?: EncodingOptionsPreset | EncodingOptions;\n}\n\n/**\n * Used to supply multiple outputs with an egress request\n */\nexport interface EncodedOutputs {\n  file?: EncodedFileOutput | undefined;\n  stream?: StreamOutput | undefined;\n  segments?: SegmentedFileOutput | undefined;\n  images?: ImageOutput | undefined;\n}\n\nexport interface ListEgressOptions {\n  roomName?: string;\n  egressId?: string;\n  active?: boolean;\n}\n\n/**\n * Client to access Egress APIs\n */\nexport class EgressClient extends ServiceBase {\n  private readonly rpc: Rpc;\n\n  /**\n   * @param host - hostname including protocol. i.e. 'https://<project>.livekit.cloud'\n   * @param apiKey - API Key, can be set in env var LIVEKIT_API_KEY\n   * @param secret - API Secret, can be set in env var LIVEKIT_API_SECRET\n   */\n  constructor(host: string, apiKey?: string, secret?: string) {\n    super(apiKey, secret);\n    this.rpc = new TwirpRpc(host, livekitPackage);\n  }\n\n  /**\n   * @param roomName - room name\n   * @param output - file or stream output\n   * @param opts - RoomCompositeOptions\n   */\n  async startRoomCompositeEgress(\n    roomName: string,\n    output: EncodedOutputs | EncodedFileOutput | StreamOutput | SegmentedFileOutput,\n    opts?: RoomCompositeOptions,\n  ): Promise<EgressInfo>;\n  /**\n   * @deprecated use RoomCompositeOptions instead\n   */\n  async startRoomCompositeEgress(\n    roomName: string,\n    output: EncodedOutputs | EncodedFileOutput | StreamOutput | SegmentedFileOutput,\n    layout?: string,\n    options?: EncodingOptionsPreset | EncodingOptions,\n    audioOnly?: boolean,\n    videoOnly?: boolean,\n    customBaseUrl?: string,\n    audioMixing?: AudioMixing,\n  ): Promise<EgressInfo>;\n  async startRoomCompositeEgress(\n    roomName: string,\n    output: EncodedOutputs | EncodedFileOutput | StreamOutput | SegmentedFileOutput,\n    optsOrLayout?: RoomCompositeOptions | string,\n    options?: EncodingOptionsPreset | EncodingOptions,\n    audioOnly?: boolean,\n    videoOnly?: boolean,\n    customBaseUrl?: string,\n    audioMixing?: AudioMixing,\n  ): Promise<EgressInfo> {\n    let layout: string | undefined;\n    let webhooks: WebhookConfig[] | undefined;\n    if (optsOrLayout !== undefined) {\n      if (typeof optsOrLayout === 'string') {\n        layout = optsOrLayout;\n      } else {\n        const opts = <RoomCompositeOptions>optsOrLayout;\n        layout = opts.layout;\n        options = opts.encodingOptions;\n        audioOnly = opts.audioOnly;\n        videoOnly = opts.videoOnly;\n        customBaseUrl = opts.customBaseUrl;\n        audioMixing = opts.audioMixing;\n        webhooks = opts.webhooks;\n      }\n    }\n\n    layout ??= '';\n    audioOnly ??= false;\n    videoOnly ??= false;\n    customBaseUrl ??= '';\n    audioMixing ??= AudioMixing.DEFAULT_MIXING;\n\n    const {\n      output: legacyOutput,\n      options: egressOptions,\n      fileOutputs,\n      streamOutputs,\n      segmentOutputs,\n      imageOutputs,\n    } = this.getOutputParams(output, options);\n\n    const req = new RoomCompositeEgressRequest({\n      roomName,\n      layout,\n      audioOnly,\n      audioMixing,\n      videoOnly,\n      customBaseUrl,\n      output: legacyOutput,\n      options: egressOptions,\n      fileOutputs,\n      streamOutputs,\n      segmentOutputs,\n      imageOutputs,\n      webhooks,\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'StartRoomCompositeEgress',\n      req,\n      await this.authHeader({ roomRecord: true }),\n    );\n    return EgressInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * @param url - url\n   * @param output - file or stream output\n   * @param opts - WebOptions\n   */\n  async startWebEgress(\n    url: string,\n    output: EncodedOutputs | EncodedFileOutput | StreamOutput | SegmentedFileOutput,\n    opts?: WebOptions,\n  ): Promise<EgressInfo> {\n    const audioOnly = opts?.audioOnly || false;\n    const videoOnly = opts?.videoOnly || false;\n    const awaitStartSignal = opts?.awaitStartSignal || false;\n    const webhooks = opts?.webhooks || [];\n    const {\n      output: legacyOutput,\n      options,\n      fileOutputs,\n      streamOutputs,\n      segmentOutputs,\n      imageOutputs,\n    } = this.getOutputParams(output, opts?.encodingOptions);\n\n    const req = new WebEgressRequest({\n      url,\n      audioOnly,\n      videoOnly,\n      awaitStartSignal,\n      output: legacyOutput,\n      options,\n      fileOutputs,\n      streamOutputs,\n      segmentOutputs,\n      imageOutputs,\n      webhooks,\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'StartWebEgress',\n      req,\n      await this.authHeader({ roomRecord: true }),\n    );\n    return EgressInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * Export a participant's audio and video tracks,\n   *\n   * @param roomName - room name\n   * @param output - one or more outputs\n   * @param opts - ParticipantEgressOptions\n   */\n  async startParticipantEgress(\n    roomName: string,\n    identity: string,\n    output: EncodedOutputs,\n    opts?: ParticipantEgressOptions,\n  ): Promise<EgressInfo> {\n    const webhooks = opts?.webhooks || [];\n    const { options, fileOutputs, streamOutputs, segmentOutputs, imageOutputs } =\n      this.getOutputParams(output, opts?.encodingOptions);\n    const req = new ParticipantEgressRequest({\n      roomName,\n      identity,\n      screenShare: opts?.screenShare ?? false,\n      options,\n      fileOutputs,\n      streamOutputs,\n      segmentOutputs,\n      imageOutputs,\n      webhooks,\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'StartParticipantEgress',\n      req,\n      await this.authHeader({ roomRecord: true }),\n    );\n    return EgressInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * @param roomName - room name\n   * @param output - file or stream output\n   * @param opts - TrackCompositeOptions\n   */\n  async startTrackCompositeEgress(\n    roomName: string,\n    output: EncodedOutputs | EncodedFileOutput | StreamOutput | SegmentedFileOutput,\n    opts?: TrackCompositeOptions,\n  ): Promise<EgressInfo>;\n  /**\n   * @deprecated use TrackCompositeOptions instead\n   */\n  async startTrackCompositeEgress(\n    roomName: string,\n    output: EncodedOutputs | EncodedFileOutput | StreamOutput | SegmentedFileOutput,\n    audioTrackId?: string,\n    videoTrackId?: string,\n    options?: EncodingOptionsPreset | EncodingOptions,\n  ): Promise<EgressInfo>;\n  async startTrackCompositeEgress(\n    roomName: string,\n    output: EncodedOutputs | EncodedFileOutput | StreamOutput | SegmentedFileOutput,\n    optsOrAudioTrackId?: TrackCompositeOptions | string,\n    videoTrackId?: string,\n    options?: EncodingOptionsPreset | EncodingOptions,\n  ): Promise<EgressInfo> {\n    let audioTrackId: string | undefined;\n    let webhooks: WebhookConfig[] | undefined;\n    if (optsOrAudioTrackId !== undefined) {\n      if (typeof optsOrAudioTrackId === 'string') {\n        audioTrackId = optsOrAudioTrackId;\n      } else {\n        const opts = <TrackCompositeOptions>optsOrAudioTrackId;\n        audioTrackId = opts.audioTrackId;\n        videoTrackId = opts.videoTrackId;\n        options = opts.encodingOptions;\n        webhooks = opts.webhooks;\n      }\n    }\n\n    audioTrackId ??= '';\n    videoTrackId ??= '';\n\n    const {\n      output: legacyOutput,\n      options: egressOptions,\n      fileOutputs,\n      streamOutputs,\n      segmentOutputs,\n      imageOutputs,\n    } = this.getOutputParams(output, options);\n    const req = new TrackCompositeEgressRequest({\n      roomName,\n      audioTrackId,\n      videoTrackId,\n      output: legacyOutput,\n      options: egressOptions,\n      fileOutputs,\n      streamOutputs,\n      segmentOutputs,\n      imageOutputs,\n      webhooks,\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'StartTrackCompositeEgress',\n      req,\n      await this.authHeader({ roomRecord: true }),\n    );\n    return EgressInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private isEncodedOutputs(output: any): output is EncodedOutputs {\n    return (\n      (<EncodedOutputs>output).file !== undefined ||\n      (<EncodedOutputs>output).stream !== undefined ||\n      (<EncodedOutputs>output).segments !== undefined ||\n      (<EncodedOutputs>output).images !== undefined\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private isEncodedFileOutput(output: any): output is EncodedFileOutput {\n    return (\n      (<EncodedFileOutput>output).filepath !== undefined ||\n      (<EncodedFileOutput>output).fileType !== undefined\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private isSegmentedFileOutput(output: any): output is SegmentedFileOutput {\n    return (\n      (<SegmentedFileOutput>output).filenamePrefix !== undefined ||\n      (<SegmentedFileOutput>output).playlistName !== undefined ||\n      (<SegmentedFileOutput>output).filenameSuffix !== undefined\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private isStreamOutput(output: any): output is StreamOutput {\n    return (\n      (<StreamOutput>output).protocol !== undefined || (<StreamOutput>output).urls !== undefined\n    );\n  }\n\n  private getOutputParams(\n    output: EncodedOutputs | EncodedFileOutput | StreamOutput | SegmentedFileOutput,\n    opts?: EncodingOptionsPreset | EncodingOptions,\n  ) {\n    let file: EncodedFileOutput | undefined;\n    let fileOutputs: Array<EncodedFileOutput> | undefined;\n    let stream: StreamOutput | undefined;\n    let streamOutputs: Array<StreamOutput> | undefined;\n    let segments: SegmentedFileOutput | undefined;\n    let segmentOutputs: Array<SegmentedFileOutput> | undefined;\n    let imageOutputs: Array<ImageOutput> | undefined;\n\n    if (this.isEncodedOutputs(output)) {\n      if (output.file !== undefined) {\n        fileOutputs = [output.file];\n      }\n      if (output.stream !== undefined) {\n        streamOutputs = [output.stream];\n      }\n      if (output.segments !== undefined) {\n        segmentOutputs = [output.segments];\n      }\n      if (output.images !== undefined) {\n        imageOutputs = [output.images];\n      }\n    } else if (this.isEncodedFileOutput(output)) {\n      file = output;\n      fileOutputs = [file];\n    } else if (this.isSegmentedFileOutput(output)) {\n      segments = output;\n      segmentOutputs = [segments];\n    } else if (this.isStreamOutput(output)) {\n      stream = output;\n      streamOutputs = [stream];\n    }\n\n    let legacyOutput:\n      | {\n          value: EncodedFileOutput;\n          case: 'file';\n        }\n      | {\n          value: StreamOutput;\n          case: 'stream';\n        }\n      | {\n          value: SegmentedFileOutput;\n          case: 'segments';\n        }\n      | undefined;\n\n    if (file) {\n      legacyOutput = {\n        case: 'file',\n        value: file,\n      };\n    } else if (stream) {\n      legacyOutput = {\n        case: 'stream',\n        value: stream,\n      };\n    } else if (segments) {\n      legacyOutput = {\n        case: 'segments',\n        value: segments,\n      };\n    }\n    let egressOptions:\n      | {\n          value: EncodingOptionsPreset;\n          case: 'preset';\n        }\n      | {\n          value: EncodingOptions;\n          case: 'advanced';\n        }\n      | undefined;\n    if (opts) {\n      if (typeof opts === 'number') {\n        egressOptions = {\n          case: 'preset',\n          value: opts,\n        };\n      } else {\n        egressOptions = {\n          case: 'advanced',\n          value: <EncodingOptions>opts,\n        };\n      }\n    }\n\n    return {\n      output: legacyOutput,\n      options: egressOptions,\n      fileOutputs,\n      streamOutputs,\n      segmentOutputs,\n      imageOutputs,\n    };\n  }\n\n  /**\n   * @param roomName - room name\n   * @param output - file or websocket output\n   * @param trackId - track Id\n   */\n  async startTrackEgress(\n    roomName: string,\n    output: DirectFileOutput | string,\n    trackId: string,\n    webhooks?: WebhookConfig[],\n  ): Promise<EgressInfo> {\n    let legacyOutput:\n      | {\n          value: DirectFileOutput;\n          case: 'file';\n        }\n      | {\n          value: string;\n          case: 'websocketUrl';\n        }\n      | undefined;\n\n    if (typeof output === 'string') {\n      legacyOutput = {\n        case: 'websocketUrl',\n        value: output,\n      };\n    } else {\n      legacyOutput = {\n        case: 'file',\n        value: output,\n      };\n    }\n\n    const req = new TrackEgressRequest({\n      roomName,\n      trackId,\n      output: legacyOutput,\n      webhooks,\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'StartTrackEgress',\n      req,\n      await this.authHeader({ roomRecord: true }),\n    );\n    return EgressInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * @param egressId -\n   * @param layout -\n   */\n  async updateLayout(egressId: string, layout: string): Promise<EgressInfo> {\n    const data = await this.rpc.request(\n      svc,\n      'UpdateLayout',\n      new UpdateLayoutRequest({ egressId, layout }).toJson(),\n      await this.authHeader({ roomRecord: true }),\n    );\n    return EgressInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * @param egressId -\n   * @param addOutputUrls -\n   * @param removeOutputUrls -\n   */\n  async updateStream(\n    egressId: string,\n    addOutputUrls?: string[],\n    removeOutputUrls?: string[],\n  ): Promise<EgressInfo> {\n    addOutputUrls ??= [];\n    removeOutputUrls ??= [];\n\n    const data = await this.rpc.request(\n      svc,\n      'UpdateStream',\n      new UpdateStreamRequest({ egressId, addOutputUrls, removeOutputUrls }).toJson(),\n      await this.authHeader({ roomRecord: true }),\n    );\n    return EgressInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * @param options - options to filter listed Egresses, by default returns all\n   * Egress instances\n   */\n  async listEgress(options?: ListEgressOptions): Promise<Array<EgressInfo>>;\n  /**\n   * @deprecated use `listEgress(options?: ListEgressOptions)` instead\n   * @param roomName - list egress for one room only\n   */\n  async listEgress(roomName?: string): Promise<Array<EgressInfo>>;\n  /**\n   * @param roomName - list egress for one room only\n   */\n  async listEgress(options?: string | ListEgressOptions): Promise<Array<EgressInfo>> {\n    let req: Partial<ListEgressRequest> = {};\n    if (typeof options === 'string') {\n      req.roomName = options;\n    } else if (options !== undefined) {\n      req = options;\n    }\n\n    const data = await this.rpc.request(\n      svc,\n      'ListEgress',\n      new ListEgressRequest(req).toJson(),\n      await this.authHeader({ roomRecord: true }),\n    );\n    return ListEgressResponse.fromJson(data, { ignoreUnknownFields: true }).items ?? [];\n  }\n\n  /**\n   * @param egressId -\n   */\n  async stopEgress(egressId: string): Promise<EgressInfo> {\n    const data = await this.rpc.request(\n      svc,\n      'StopEgress',\n      new StopEgressRequest({ egressId }).toJson(),\n      await this.authHeader({ roomRecord: true }),\n    );\n    return EgressInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 775, "column": 0}, "map": {"version":3,"sources":["file:///D:/uplift-demo/demo/node_modules/livekit-server-sdk/src/IngressClient.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { IngressAudioOptions, IngressInput, IngressVideoOptions } from '@livekit/protocol';\nimport {\n  CreateIngressRequest,\n  DeleteIngressRequest,\n  IngressInfo,\n  ListIngressRequest,\n  ListIngressResponse,\n  UpdateIngressRequest,\n} from '@livekit/protocol';\nimport { ServiceBase } from './ServiceBase.js';\nimport type { Rpc } from './TwirpRPC.js';\nimport { TwirpRpc, livekitPackage } from './TwirpRPC.js';\n\nconst svc = 'Ingress';\n\nexport interface CreateIngressOptions {\n  /**\n   * ingress name. optional\n   */\n  name?: string;\n  /**\n   * name of the room to send media to. required\n   */\n  roomName?: string;\n  /**\n   * unique identity of the participant. required\n   */\n  participantIdentity: string;\n  /**\n   * participant display name\n   */\n  participantName?: string;\n  /**\n   * metadata to attach to the participant\n   */\n  participantMetadata?: string;\n  /**\n   * @deprecated use `enableTranscoding` instead.\n   * whether to skip transcoding and forward the input media directly. Only supported by WHIP\n   */\n  bypassTranscoding?: boolean;\n  /**\n   * whether to enable transcoding or forward the input media directly.\n   * Transcoding is required for all input types except WHIP. For WHIP, the default is to not transcode.\n   */\n  enableTranscoding?: boolean | undefined;\n  /**\n   * url of the media to pull for ingresses of type URL\n   */\n  url?: string;\n  /**\n   * custom audio encoding parameters. optional\n   */\n  audio?: IngressAudioOptions;\n  /**\n   * custom video encoding parameters. optional\n   */\n  video?: IngressVideoOptions;\n}\n\nexport interface UpdateIngressOptions {\n  /**\n   * ingress name. optional\n   */\n  name: string;\n  /**\n   * name of the room to send media to.\n   */\n  roomName?: string;\n  /**\n   * unique identity of the participant.\n   */\n  participantIdentity?: string;\n  /**\n   * participant display name\n   */\n  participantName?: string;\n  /**\n   * metadata to attach to the participant\n   */\n  participantMetadata?: string;\n  /**\n   * @deprecated use `enableTranscoding` instead\n   * whether to skip transcoding and forward the input media directly. Only supported by WHIP\n   */\n  bypassTranscoding?: boolean | undefined;\n  /**\n   * whether to enable transcoding or forward the input media directly.\n   * Transcoding is required for all input types except WHIP. For WHIP, the default is to not transcode.\n   */\n  enableTranscoding?: boolean | undefined;\n  /**\n   * custom audio encoding parameters. optional\n   */\n  audio?: IngressAudioOptions;\n  /**\n   * custom video encoding parameters. optional\n   */\n  video?: IngressVideoOptions;\n}\n\nexport interface ListIngressOptions {\n  /**\n   * list ingress for one room only\n   */\n  roomName?: string;\n\n  /**\n   * list ingress by ID\n   */\n  ingressId?: string;\n}\n\n/**\n * Client to access Ingress APIs\n */\nexport class IngressClient extends ServiceBase {\n  private readonly rpc: Rpc;\n\n  /**\n   * @param host - hostname including protocol. i.e. 'https://<project>.livekit.cloud'\n   * @param apiKey - API Key, can be set in env var LIVEKIT_API_KEY\n   * @param secret - API Secret, can be set in env var LIVEKIT_API_SECRET\n   */\n  constructor(host: string, apiKey?: string, secret?: string) {\n    super(apiKey, secret);\n    this.rpc = new TwirpRpc(host, livekitPackage);\n  }\n\n  /**\n   * @param inputType - protocol for the ingress\n   * @param opts - CreateIngressOptions\n   */\n  async createIngress(inputType: IngressInput, opts: CreateIngressOptions): Promise<IngressInfo> {\n    let name: string = '';\n    let participantName: string = '';\n    let participantIdentity: string = '';\n    let bypassTranscoding: boolean = false;\n    let url: string = '';\n\n    if (opts == null) {\n      throw new Error('options dictionary is required');\n    }\n\n    const roomName: string | undefined = opts.roomName;\n    const enableTranscoding: boolean | undefined = opts.enableTranscoding;\n    const audio: IngressAudioOptions | undefined = opts.audio;\n    const video: IngressVideoOptions | undefined = opts.video;\n    const participantMetadata: string | undefined = opts.participantMetadata;\n\n    name = opts.name || '';\n    participantName = opts.participantName || '';\n    participantIdentity = opts.participantIdentity || '';\n    bypassTranscoding = opts.bypassTranscoding || false;\n    url = opts.url || '';\n\n    if (typeof roomName == 'undefined') {\n      throw new Error('required roomName option not provided');\n    }\n\n    if (participantIdentity == '') {\n      throw new Error('required participantIdentity option not provided');\n    }\n\n    const req = new CreateIngressRequest({\n      inputType,\n      name,\n      roomName,\n      participantIdentity,\n      participantMetadata,\n      participantName,\n      bypassTranscoding,\n      enableTranscoding,\n      url,\n      audio,\n      video,\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'CreateIngress',\n      req,\n      await this.authHeader({ ingressAdmin: true }),\n    );\n    return IngressInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * @param ingressId - ID of the ingress to update\n   * @param opts - UpdateIngressOptions\n   */\n  async updateIngress(ingressId: string, opts: UpdateIngressOptions): Promise<IngressInfo> {\n    const name: string = opts.name || '';\n    const roomName: string = opts.roomName || '';\n    const participantName: string = opts.participantName || '';\n    const participantIdentity: string = opts.participantIdentity || '';\n    const { participantMetadata } = opts;\n    const { audio, video, bypassTranscoding, enableTranscoding } = opts;\n\n    const req = new UpdateIngressRequest({\n      ingressId,\n      name,\n      roomName,\n      participantIdentity,\n      participantName,\n      participantMetadata,\n      bypassTranscoding,\n      enableTranscoding,\n      audio,\n      video,\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'UpdateIngress',\n      req,\n      await this.authHeader({ ingressAdmin: true }),\n    );\n    return IngressInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * @deprecated use `listIngress(opts)` or `listIngress(arg)` instead\n   * @param roomName - list ingress for one room only\n   */\n  async listIngress(roomName?: string): Promise<Array<IngressInfo>>;\n  /**\n   * @param opts - list options\n   */\n  async listIngress(opts?: ListIngressOptions): Promise<Array<IngressInfo>>;\n  /**\n   * @param arg - list room name or options\n   */\n  async listIngress(arg?: string | ListIngressOptions): Promise<Array<IngressInfo>> {\n    let req: Partial<ListIngressRequest> = {};\n    if (typeof arg === 'string') {\n      req.roomName = arg;\n    } else if (arg) {\n      req = arg;\n    }\n    const data = await this.rpc.request(\n      svc,\n      'ListIngress',\n      new ListIngressRequest(req).toJson(),\n      await this.authHeader({ ingressAdmin: true }),\n    );\n    return ListIngressResponse.fromJson(data, { ignoreUnknownFields: true }).items ?? [];\n  }\n\n  /**\n   * @param ingressId - ingress to delete\n   */\n  async deleteIngress(ingressId: string): Promise<IngressInfo> {\n    const data = await this.rpc.request(\n      svc,\n      'DeleteIngress',\n      new DeleteIngressRequest({ ingressId }).toJson(),\n      await this.authHeader({ ingressAdmin: true }),\n    );\n    return IngressInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 907, "column": 0}, "map": {"version":3,"sources":["file:///D:/uplift-demo/demo/node_modules/livekit-server-sdk/src/crypto/uuid.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n// Use the Web Crypto API if available, otherwise fallback to Node.js crypto\nexport async function getRandomBytes(size: number = 16): Promise<Uint8Array> {\n  if (globalThis.crypto) {\n    return crypto.getRandomValues(new Uint8Array(size));\n  } else {\n    const nodeCrypto = await import('node:crypto');\n    return nodeCrypto.getRandomValues(new Uint8Array(size));\n  }\n}\n"],"names":[],"mappings":";;;;AAKA,eAAsB,eAAe,OAAe,EAAA,EAAyB;IAC3E,IAAI,WAAW,MAAA,EAAQ;QACrB,OAAO,OAAO,eAAA,CAAgB,IAAI,WAAW,IAAI,CAAC;IACpD,OAAO;QACL,MAAM,aAAa,MAAM,OAAO,aAAa;QAC7C,OAAO,WAAW,eAAA,CAAgB,IAAI,WAAW,IAAI,CAAC;IACxD;AACF","debugId":null}},
    {"offset": {"line": 925, "column": 0}, "map": {"version":3,"sources":["file:///D:/uplift-demo/demo/node_modules/livekit-server-sdk/src/RoomServiceClient.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { DataPacket_Kind, RoomAgentDispatch, RoomEgress, TrackInfo } from '@livekit/protocol';\nimport {\n  CreateRoomRequest,\n  DeleteRoomRequest,\n  ForwardParticipantRequest,\n  ListParticipantsRequest,\n  ListParticipantsResponse,\n  ListRoomsRequest,\n  ListRoomsResponse,\n  MoveParticipantRequest,\n  MuteRoomTrackRequest,\n  MuteRoomTrackResponse,\n  ParticipantInfo,\n  ParticipantPermission,\n  Room,\n  RoomParticipantIdentity,\n  SendDataRequest,\n  UpdateParticipantRequest,\n  UpdateRoomMetadataRequest,\n  UpdateSubscriptionsRequest,\n} from '@livekit/protocol';\nimport { ServiceBase } from './ServiceBase.js';\nimport type { Rpc } from './TwirpRPC.js';\nimport { TwirpRpc, livekitPackage } from './TwirpRPC.js';\nimport { getRandomBytes } from './crypto/uuid.js';\n\n/**\n * Options for when creating a room\n */\nexport interface CreateOptions {\n  /**\n   * name of the room. required\n   */\n  name: string;\n\n  /**\n   * number of seconds to keep the room open before any participant joins\n   */\n  emptyTimeout?: number;\n\n  /**\n   * number of seconds to keep the room open after the last participant leaves\n   * this option is helpful to give a grace period for participants to re-join\n   */\n  departureTimeout?: number;\n\n  /**\n   * limit to the number of participants in a room at a time\n   */\n  maxParticipants?: number;\n\n  /**\n   * initial room metadata\n   */\n  metadata?: string;\n\n  /**\n   * add egress options\n   */\n  egress?: RoomEgress;\n\n  /**\n   * minimum playout delay in milliseconds\n   */\n  minPlayoutDelay?: number;\n\n  /**\n   * maximum playout delay in milliseconds\n   */\n  maxPlayoutDelay?: number;\n\n  /**\n   * improves A/V sync when min_playout_delay set to a value larger than 200ms.\n   * It will disables transceiver re-use -- this option is not recommended\n   * for rooms with frequent subscription changes\n   */\n  syncStreams?: boolean;\n\n  /**\n   * agents that should be dispatched to this room\n   */\n  agents?: RoomAgentDispatch[];\n\n  /**\n   * override the node room is allocated to, for debugging\n   * does not work with Cloud\n   */\n  nodeId?: string;\n}\n\nexport type SendDataOptions = {\n  /** If set, only deliver to listed participant identities */\n  destinationIdentities?: string[];\n  destinationSids?: string[];\n  topic?: string;\n};\n\nexport type UpdateParticipantOptions = {\n  /** only attributes you'd want to update should be set, set value to empty string to remove it */\n  attributes?: { [key: string]: string };\n  metadata?: string;\n  /** permissions are updated atomically - all desired permissions would need to be set */\n  permission?: Partial<ParticipantPermission>;\n  name?: string;\n};\n\nconst svc = 'RoomService';\n\n/**\n * Client to access Room APIs\n */\nexport class RoomServiceClient extends ServiceBase {\n  private readonly rpc: Rpc;\n\n  /**\n   *\n   * @param host - hostname including protocol. i.e. 'https://<project>.livekit.cloud'\n   * @param apiKey - API Key, can be set in env var LIVEKIT_API_KEY\n   * @param secret - API Secret, can be set in env var LIVEKIT_API_SECRET\n   */\n  constructor(host: string, apiKey?: string, secret?: string) {\n    super(apiKey, secret);\n    this.rpc = new TwirpRpc(host, livekitPackage);\n  }\n\n  /**\n   * Creates a new room. Explicit room creation is not required, since rooms will\n   * be automatically created when the first participant joins. This method can be\n   * used to customize room settings.\n   * @param options -\n   */\n  async createRoom(options: CreateOptions): Promise<Room> {\n    const data = await this.rpc.request(\n      svc,\n      'CreateRoom',\n      new CreateRoomRequest(options).toJson(),\n      await this.authHeader({ roomCreate: true }),\n    );\n    return Room.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * List active rooms\n   * @param names - when undefined or empty, list all rooms.\n   *                otherwise returns rooms with matching names\n   * @returns\n   */\n  async listRooms(names?: string[]): Promise<Room[]> {\n    const data = await this.rpc.request(\n      svc,\n      'ListRooms',\n      new ListRoomsRequest({ names: names ?? [] }).toJson(),\n      await this.authHeader({ roomList: true }),\n    );\n    const res = ListRoomsResponse.fromJson(data, { ignoreUnknownFields: true });\n    return res.rooms ?? [];\n  }\n\n  async deleteRoom(room: string): Promise<void> {\n    await this.rpc.request(\n      svc,\n      'DeleteRoom',\n      new DeleteRoomRequest({ room }).toJson(),\n      await this.authHeader({ roomCreate: true }),\n    );\n  }\n\n  /**\n   * Update metadata of a room\n   * @param room - name of the room\n   * @param metadata - the new metadata for the room\n   */\n  async updateRoomMetadata(room: string, metadata: string) {\n    const data = await this.rpc.request(\n      svc,\n      'UpdateRoomMetadata',\n      new UpdateRoomMetadataRequest({ room, metadata }).toJson(),\n      await this.authHeader({ roomAdmin: true, room }),\n    );\n    return Room.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * List participants in a room\n   * @param room - name of the room\n   */\n  async listParticipants(room: string): Promise<ParticipantInfo[]> {\n    const data = await this.rpc.request(\n      svc,\n      'ListParticipants',\n      new ListParticipantsRequest({ room }).toJson(),\n      await this.authHeader({ roomAdmin: true, room }),\n    );\n    const res = ListParticipantsResponse.fromJson(data, { ignoreUnknownFields: true });\n    return res.participants ?? [];\n  }\n\n  /**\n   * Get information on a specific participant, including the tracks that participant\n   * has published\n   * @param room - name of the room\n   * @param identity - identity of the participant to return\n   */\n  async getParticipant(room: string, identity: string): Promise<ParticipantInfo> {\n    const data = await this.rpc.request(\n      svc,\n      'GetParticipant',\n      new RoomParticipantIdentity({ room, identity }).toJson(),\n      await this.authHeader({ roomAdmin: true, room }),\n    );\n\n    return ParticipantInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * Removes a participant in the room. This will disconnect the participant\n   * and will emit a Disconnected event for that participant.\n   * Even after being removed, the participant can still re-join the room.\n   * @param room -\n   * @param identity -\n   */\n  async removeParticipant(room: string, identity: string): Promise<void> {\n    await this.rpc.request(\n      svc,\n      'RemoveParticipant',\n      new RoomParticipantIdentity({ room, identity }).toJson(),\n      await this.authHeader({ roomAdmin: true, room }),\n    );\n  }\n\n  /**\n   * Forwards a participant's track to another room. This will create a\n   * participant to join the destination room that has same information\n   * with the source participant except the kind to be `Forwarded`. All\n   * changes to the source participant will be reflected to the forwarded\n   * participant. When the source participant disconnects or the\n   * `RemoveParticipant` method is called in the destination room, the\n   * forwarding will be stopped.\n   * @param room -\n   * @param identity -\n   * @param destinationRoom - the room to forward the participant to\n   */\n  async forwardParticipant(room: string, identity: string, destinationRoom: string): Promise<void> {\n    await this.rpc.request(\n      svc,\n      'ForwardParticipant',\n      new ForwardParticipantRequest({ room, identity, destinationRoom }).toJson(),\n      await this.authHeader({ roomAdmin: true, room, destinationRoom }),\n    );\n  }\n\n  /**\n   * Move a connected participant to a different room. Requires `roomAdmin` and `destinationRoom`.\n   * The participant will be removed from the current room and added to the destination room.\n   * From the other observers' perspective, the participant would've disconnected from the previous room and joined the new one.\n   * @param room -\n   * @param identity -\n   * @param destinationRoom - the room to move the participant to\n   */\n  async moveParticipant(room: string, identity: string, destinationRoom: string): Promise<void> {\n    await this.rpc.request(\n      svc,\n      'MoveParticipant',\n      new MoveParticipantRequest({ room, identity, destinationRoom }).toJson(),\n      await this.authHeader({ roomAdmin: true, room, destinationRoom }),\n    );\n  }\n\n  /**\n   * Mutes a track that the participant has published.\n   * @param room -\n   * @param identity -\n   * @param trackSid - sid of the track to be muted\n   * @param muted - true to mute, false to unmute\n   */\n  async mutePublishedTrack(\n    room: string,\n    identity: string,\n    trackSid: string,\n    muted: boolean,\n  ): Promise<TrackInfo> {\n    const req = new MuteRoomTrackRequest({\n      room,\n      identity,\n      trackSid,\n      muted,\n    }).toJson();\n    const data = await this.rpc.request(\n      svc,\n      'MutePublishedTrack',\n      req,\n      await this.authHeader({ roomAdmin: true, room }),\n    );\n    const res = MuteRoomTrackResponse.fromJson(data, { ignoreUnknownFields: true });\n    return res.track!;\n  }\n\n  /**\n   * Updates a participant's state or permissions\n   * @param room - target room\n   * @param identity - participant identity\n   * @param options - participant fields to update\n   */\n  async updateParticipant(\n    room: string,\n    identity: string,\n    options: UpdateParticipantOptions,\n  ): Promise<ParticipantInfo>;\n  /**\n   * Updates a participant's state or permissions\n   * @param room - target room\n   * @param identity - participant identity\n   * @param options - participant fields to update\n   */\n  async updateParticipant(\n    room: string,\n    identity: string,\n    metadata?: string,\n    permission?: Partial<ParticipantPermission>,\n    name?: string,\n  ): Promise<ParticipantInfo>;\n  async updateParticipant(\n    room: string,\n    identity: string,\n    metadataOrOptions?: string | UpdateParticipantOptions,\n    maybePermission?: Partial<ParticipantPermission>,\n    maybeName?: string,\n  ): Promise<ParticipantInfo> {\n    const hasOptions = typeof metadataOrOptions === 'object';\n    const metadata = hasOptions ? metadataOrOptions?.metadata : metadataOrOptions;\n    const permission = hasOptions ? metadataOrOptions.permission : maybePermission;\n    const name = hasOptions ? metadataOrOptions.name : maybeName;\n    const attributes: Record<string, string> | undefined = hasOptions\n      ? metadataOrOptions.attributes\n      : {};\n\n    const req = new UpdateParticipantRequest({\n      room,\n      identity,\n      attributes,\n      metadata,\n      name,\n    });\n    if (permission) {\n      req.permission = new ParticipantPermission(permission);\n    }\n    const data = await this.rpc.request(\n      svc,\n      'UpdateParticipant',\n      req.toJson(),\n      await this.authHeader({ roomAdmin: true, room }),\n    );\n    return ParticipantInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * Updates a participant's subscription to tracks\n   * @param room -\n   * @param identity -\n   * @param trackSids -\n   * @param subscribe - true to subscribe, false to unsubscribe\n   */\n  async updateSubscriptions(\n    room: string,\n    identity: string,\n    trackSids: string[],\n    subscribe: boolean,\n  ): Promise<void> {\n    const req = new UpdateSubscriptionsRequest({\n      room,\n      identity,\n      trackSids,\n      subscribe,\n      participantTracks: [],\n    }).toJson();\n    await this.rpc.request(\n      svc,\n      'UpdateSubscriptions',\n      req,\n      await this.authHeader({ roomAdmin: true, room }),\n    );\n  }\n\n  /**\n   * Sends data message to participants in the room\n   * @param room -\n   * @param data - opaque payload to send\n   * @param kind - delivery reliability\n   * @param options - optionally specify a topic and destinationSids (when destinationSids is empty, message is sent to everyone)\n   */\n  async sendData(\n    room: string,\n    data: Uint8Array,\n    kind: DataPacket_Kind,\n    options: SendDataOptions,\n  ): Promise<void>;\n  /**\n   * Sends data message to participants in the room\n   * @deprecated use sendData(room, data, kind, options) instead\n   * @param room -\n   * @param data - opaque payload to send\n   * @param kind - delivery reliability\n   * @param destinationSids - optional. when empty, message is sent to everyone\n   */\n  async sendData(\n    room: string,\n    data: Uint8Array,\n    kind: DataPacket_Kind,\n    destinationSids?: string[],\n  ): Promise<void>;\n  async sendData(\n    room: string,\n    data: Uint8Array,\n    kind: DataPacket_Kind,\n    options: SendDataOptions | string[] = {},\n  ): Promise<void> {\n    const destinationSids = Array.isArray(options) ? options : options.destinationSids;\n    const topic = Array.isArray(options) ? undefined : options.topic;\n    const req = new SendDataRequest({\n      room,\n      data,\n      kind,\n      destinationSids: destinationSids ?? [],\n      topic,\n    });\n    if (!Array.isArray(options) && options.destinationIdentities) {\n      req.destinationIdentities = options.destinationIdentities;\n    }\n    req.nonce = await getRandomBytes(16);\n    await this.rpc.request(\n      svc,\n      'SendData',\n      req.toJson(),\n      await this.authHeader({ roomAdmin: true, room }),\n    );\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1178, "column": 0}, "map": {"version":3,"sources":["file:///D:/uplift-demo/demo/node_modules/livekit-server-sdk/src/SipClient.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport { Duration } from '@bufbuild/protobuf';\nimport type {\n  ListUpdate,\n  Pagination,\n  RoomConfiguration,\n  SIPHeaderOptions,\n} from '@livekit/protocol';\nimport {\n  CreateSIPDispatchRuleRequest,\n  CreateSIPInboundTrunkRequest,\n  CreateSIPOutboundTrunkRequest,\n  CreateSIPParticipantRequest,\n  CreateSIPTrunkRequest,\n  DeleteSIPDispatchRuleRequest,\n  DeleteSIPTrunkRequest,\n  ListSIPDispatchRuleRequest,\n  ListSIPDispatchRuleResponse,\n  ListSIPInboundTrunkRequest,\n  ListSIPInboundTrunkResponse,\n  ListSIPOutboundTrunkRequest,\n  ListSIPOutboundTrunkResponse,\n  ListSIPTrunkRequest,\n  ListSIPTrunkResponse,\n  SIPDispatchRule,\n  SIPDispatchRuleDirect,\n  SIPDispatchRuleIndividual,\n  SIPDispatchRuleInfo,\n  SIPInboundTrunkInfo,\n  SIPOutboundTrunkInfo,\n  SIPParticipantInfo,\n  SIPTransport,\n  SIPTrunkInfo,\n  TransferSIPParticipantRequest,\n  UpdateSIPDispatchRuleRequest,\n  UpdateSIPInboundTrunkRequest,\n  UpdateSIPOutboundTrunkRequest,\n} from '@livekit/protocol';\nimport { ServiceBase } from './ServiceBase.js';\nimport type { Rpc } from './TwirpRPC.js';\nimport { TwirpRpc, livekitPackage } from './TwirpRPC.js';\n\nconst svc = 'SIP';\n\n/**\n * @deprecated use CreateSipInboundTrunkOptions or CreateSipOutboundTrunkOptions\n */\nexport interface CreateSipTrunkOptions {\n  name?: string;\n  metadata?: string;\n  inbound_addresses?: string[];\n  inbound_numbers?: string[];\n  inbound_username?: string;\n  inbound_password?: string;\n  outbound_address?: string;\n  outbound_username?: string;\n  outbound_password?: string;\n}\nexport interface CreateSipInboundTrunkOptions {\n  metadata?: string;\n  /** @deprecated - use `allowedAddresses` instead */\n  allowed_addresses?: string[];\n  allowedAddresses?: string[];\n  /** @deprecated - use `allowedNumbers` instead */\n  allowed_numbers?: string[];\n  allowedNumbers?: string[];\n  /** @deprecated - use `authUsername` instead */\n  auth_username?: string;\n  authUsername?: string;\n  /** @deprecated - use `authPassword` instead */\n  auth_password?: string;\n  authPassword?: string;\n  headers?: { [key: string]: string };\n  headersToAttributes?: { [key: string]: string };\n  // Map SIP response headers from INVITE to sip.h.* participant attributes automatically.\n  includeHeaders?: SIPHeaderOptions;\n  krispEnabled?: boolean;\n}\nexport interface CreateSipOutboundTrunkOptions {\n  metadata?: string;\n  transport: SIPTransport;\n  destinationCountry?: string;\n  /** @deprecated - use `authUsername` instead */\n  auth_username?: string;\n  authUsername?: string;\n  /** @deprecated - use `authPassword` instead */\n  auth_password?: string;\n  authPassword?: string;\n  headers?: { [key: string]: string };\n  headersToAttributes?: { [key: string]: string };\n  // Map SIP response headers from INVITE to sip.h.* participant attributes automatically.\n  includeHeaders?: SIPHeaderOptions;\n}\n\nexport interface SipDispatchRuleDirect {\n  type: 'direct';\n  roomName: string;\n  pin?: string;\n}\n\nexport interface SipDispatchRuleIndividual {\n  type: 'individual';\n  roomPrefix: string;\n  pin?: string;\n}\n\nexport interface CreateSipDispatchRuleOptions {\n  name?: string;\n  metadata?: string;\n  trunkIds?: string[];\n  hidePhoneNumber?: boolean;\n  attributes?: { [key: string]: string };\n  roomPreset?: string;\n  roomConfig?: RoomConfiguration;\n}\n\nexport interface CreateSipParticipantOptions {\n  /** Optional SIP From number to use. If empty, trunk number is used. */\n  fromNumber?: string;\n  /** Optional identity of the SIP participant */\n  participantIdentity?: string;\n  /** Optional name of the participant */\n  participantName?: string;\n  /** Optional display name for the SIP participant */\n  displayName?: string;\n  /** Optional metadata to attach to the participant */\n  participantMetadata?: string;\n  /** Optional attributes to attach to the participant */\n  participantAttributes?: { [key: string]: string };\n  /** Optionally send following DTMF digits (extension codes) when making a call.\n   * Character 'w' can be used to add a 0.5 sec delay. */\n  dtmf?: string;\n  /** @deprecated use `playDialtone` instead */\n  playRingtone?: boolean;\n  /** If `true`, the SIP Participant plays a dial tone to the room until the phone is picked up. */\n  playDialtone?: boolean;\n  /** These headers are sent as-is and may help identify this call as coming from LiveKit for the other SIP endpoint. */\n  headers?: { [key: string]: string };\n  /** Map SIP response headers from INVITE to sip.h.* participant attributes automatically. */\n  includeHeaders?: SIPHeaderOptions;\n  hidePhoneNumber?: boolean;\n  /** Maximum time for the call to ring in seconds. */\n  ringingTimeout?: number;\n  /** Maximum call duration in seconds. */\n  maxCallDuration?: number;\n  /** If `true`, Krisp noise cancellation will be enabled for the caller. */\n  krispEnabled?: boolean;\n  /** If `true`, this will wait until the call is answered before returning. */\n  waitUntilAnswered?: boolean;\n  /** Optional request timeout in seconds. default 60 seconds if waitUntilAnswered is true, otherwise 10 seconds */\n  timeout?: number;\n}\n\nexport interface ListSipDispatchRuleOptions {\n  /** Pagination options. */\n  page?: Pagination;\n  /** Rule IDs to list. If this option is set, the response will contains rules in the same order. If any of the rules is missing, a nil item in that position will be sent in the response. */\n  dispatchRuleIds?: string[];\n  /** Only list rules that contain one of the Trunk IDs, including wildcard rules. */\n  trunkIds?: string[];\n}\n\nexport interface ListSipTrunkOptions {\n  /** Pagination options. */\n  page?: Pagination;\n  /** Trunk IDs to list. If this option is set, the response will contains trunks in the same order. If any of the trunks is missing, a nil item in that position will be sent in the response. */\n  trunkIds?: string[];\n  /** Only list trunks that contain one of the numbers, including wildcard trunks. */\n  numbers?: string[];\n}\n\nexport interface SipDispatchRuleUpdateOptions {\n  trunkIds?: ListUpdate;\n  rule?: SIPDispatchRule;\n  name?: string;\n  metadata?: string;\n  attributes?: { [key: string]: string };\n}\n\nexport interface SipInboundTrunkUpdateOptions {\n  numbers?: ListUpdate;\n  allowedAddresses?: ListUpdate;\n  allowedNumbers?: ListUpdate;\n  authUsername?: string;\n  authPassword?: string;\n  name?: string;\n  metadata?: string;\n}\n\nexport interface SipOutboundTrunkUpdateOptions {\n  numbers?: ListUpdate;\n  allowedAddresses?: ListUpdate;\n  allowedNumbers?: ListUpdate;\n  authUsername?: string;\n  authPassword?: string;\n  destinationCountry?: string;\n  name?: string;\n  metadata?: string;\n}\n\nexport interface TransferSipParticipantOptions {\n  playDialtone?: boolean;\n  headers?: { [key: string]: string };\n}\n\n/**\n * Client to access Egress APIs\n */\nexport class SipClient extends ServiceBase {\n  private readonly rpc: Rpc;\n\n  /**\n   * @param host - hostname including protocol. i.e. 'https://<project>.livekit.cloud'\n   * @param apiKey - API Key, can be set in env var LIVEKIT_API_KEY\n   * @param secret - API Secret, can be set in env var LIVEKIT_API_SECRET\n   */\n  constructor(host: string, apiKey?: string, secret?: string) {\n    super(apiKey, secret);\n    this.rpc = new TwirpRpc(host, livekitPackage);\n  }\n\n  /**\n   * @param number - phone number of the trunk\n   * @param opts - CreateSipTrunkOptions\n   * @deprecated use `createSipInboundTrunk` or `createSipOutboundTrunk`\n   */\n  async createSipTrunk(number: string, opts?: CreateSipTrunkOptions): Promise<SIPTrunkInfo> {\n    let inboundAddresses: string[] | undefined;\n    let inboundNumbers: string[] | undefined;\n    let inboundUsername: string = '';\n    let inboundPassword: string = '';\n    let outboundAddress: string = '';\n    let outboundUsername: string = '';\n    let outboundPassword: string = '';\n    let name: string = '';\n    let metadata: string = '';\n\n    if (opts !== undefined) {\n      inboundAddresses = opts.inbound_addresses;\n      inboundNumbers = opts.inbound_numbers;\n      inboundUsername = opts.inbound_username || '';\n      inboundPassword = opts.inbound_password || '';\n      outboundAddress = opts.outbound_address || '';\n      outboundUsername = opts.outbound_username || '';\n      outboundPassword = opts.outbound_password || '';\n      name = opts.name || '';\n      metadata = opts.metadata || '';\n    }\n\n    const req = new CreateSIPTrunkRequest({\n      name: name,\n      metadata: metadata,\n      inboundAddresses: inboundAddresses,\n      inboundNumbers: inboundNumbers,\n      inboundUsername: inboundUsername,\n      inboundPassword: inboundPassword,\n      outboundNumber: number,\n      outboundAddress: outboundAddress,\n      outboundUsername: outboundUsername,\n      outboundPassword: outboundPassword,\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'CreateSIPTrunk',\n      req,\n      await this.authHeader({}, { admin: true }),\n    );\n    return SIPTrunkInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * Create a new SIP inbound trunk.\n   *\n   * @param name - human-readable name of the trunk\n   * @param numbers - phone numbers of the trunk\n   * @param opts - CreateSipTrunkOptions\n   * @returns Created SIP inbound trunk\n   */\n  async createSipInboundTrunk(\n    name: string,\n    numbers: string[],\n    opts?: CreateSipInboundTrunkOptions,\n  ): Promise<SIPInboundTrunkInfo> {\n    if (opts === undefined) {\n      opts = {};\n    }\n    const req = new CreateSIPInboundTrunkRequest({\n      trunk: new SIPInboundTrunkInfo({\n        name: name,\n        numbers: numbers,\n        metadata: opts?.metadata,\n        allowedAddresses: opts.allowedAddresses ?? opts.allowed_addresses,\n        allowedNumbers: opts.allowedNumbers ?? opts.allowed_numbers,\n        authUsername: opts.authUsername ?? opts.auth_username,\n        authPassword: opts.authPassword ?? opts.auth_password,\n        headers: opts.headers,\n        headersToAttributes: opts.headersToAttributes,\n        includeHeaders: opts.includeHeaders,\n        krispEnabled: opts.krispEnabled,\n      }),\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'CreateSIPInboundTrunk',\n      req,\n      await this.authHeader({}, { admin: true }),\n    );\n    return SIPInboundTrunkInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * Create a new SIP outbound trunk.\n   *\n   * @param name - human-readable name of the trunk\n   * @param address - hostname and port of the SIP server to dial\n   * @param numbers - phone numbers of the trunk\n   * @param opts - CreateSipTrunkOptions\n   * @returns Created SIP outbound trunk\n   */\n  async createSipOutboundTrunk(\n    name: string,\n    address: string,\n    numbers: string[],\n    opts?: CreateSipOutboundTrunkOptions,\n  ): Promise<SIPOutboundTrunkInfo> {\n    if (opts === undefined) {\n      opts = {\n        transport: SIPTransport.SIP_TRANSPORT_AUTO,\n      };\n    }\n\n    const req = new CreateSIPOutboundTrunkRequest({\n      trunk: new SIPOutboundTrunkInfo({\n        name: name,\n        address: address,\n        numbers: numbers,\n        metadata: opts.metadata,\n        transport: opts.transport,\n        authUsername: opts.authUsername ?? opts.auth_username,\n        authPassword: opts.authPassword ?? opts.auth_password,\n        headers: opts.headers,\n        headersToAttributes: opts.headersToAttributes,\n        includeHeaders: opts.includeHeaders,\n        destinationCountry: opts.destinationCountry,\n      }),\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'CreateSIPOutboundTrunk',\n      req,\n      await this.authHeader({}, { admin: true }),\n    );\n    return SIPOutboundTrunkInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * @deprecated use `listSipInboundTrunk` or `listSipOutboundTrunk`\n   */\n  async listSipTrunk(): Promise<Array<SIPTrunkInfo>> {\n    const req: Partial<ListSIPTrunkRequest> = {};\n    const data = await this.rpc.request(\n      svc,\n      'ListSIPTrunk',\n      new ListSIPTrunkRequest(req).toJson(),\n      await this.authHeader({}, { admin: true }),\n    );\n    return ListSIPTrunkResponse.fromJson(data, { ignoreUnknownFields: true }).items ?? [];\n  }\n\n  /**\n   * List SIP inbound trunks with optional filtering.\n   *\n   * @param list - Request with optional filtering parameters\n   * @returns Response containing list of SIP inbound trunks\n   */\n  async listSipInboundTrunk(list: ListSipTrunkOptions = {}): Promise<Array<SIPInboundTrunkInfo>> {\n    const req = new ListSIPInboundTrunkRequest(list).toJson();\n    const data = await this.rpc.request(\n      svc,\n      'ListSIPInboundTrunk',\n      req,\n      await this.authHeader({}, { admin: true }),\n    );\n    return ListSIPInboundTrunkResponse.fromJson(data, { ignoreUnknownFields: true }).items ?? [];\n  }\n\n  /**\n   * List SIP outbound trunks with optional filtering.\n   *\n   * @param list - Request with optional filtering parameters\n   * @returns Response containing list of SIP outbound trunks\n   */\n  async listSipOutboundTrunk(list: ListSipTrunkOptions = {}): Promise<Array<SIPOutboundTrunkInfo>> {\n    const req = new ListSIPOutboundTrunkRequest(list).toJson();\n    const data = await this.rpc.request(\n      svc,\n      'ListSIPOutboundTrunk',\n      req,\n      await this.authHeader({}, { admin: true }),\n    );\n    return ListSIPOutboundTrunkResponse.fromJson(data, { ignoreUnknownFields: true }).items ?? [];\n  }\n\n  /**\n   * Delete a SIP trunk.\n   *\n   * @param sipTrunkId - ID of the SIP trunk to delete\n   * @returns Deleted trunk information\n   */\n  async deleteSipTrunk(sipTrunkId: string): Promise<SIPTrunkInfo> {\n    const data = await this.rpc.request(\n      svc,\n      'DeleteSIPTrunk',\n      new DeleteSIPTrunkRequest({ sipTrunkId }).toJson(),\n      await this.authHeader({}, { admin: true }),\n    );\n    return SIPTrunkInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * Create a new SIP dispatch rule.\n   *\n   * @param rule - SIP dispatch rule to create\n   * @param opts - CreateSipDispatchRuleOptions\n   * @returns Created SIP dispatch rule\n   */\n  async createSipDispatchRule(\n    rule: SipDispatchRuleDirect | SipDispatchRuleIndividual,\n    opts?: CreateSipDispatchRuleOptions,\n  ): Promise<SIPDispatchRuleInfo> {\n    if (opts === undefined) {\n      opts = {};\n    }\n    let ruleProto: SIPDispatchRule | undefined = undefined;\n    if (rule.type == 'direct') {\n      ruleProto = new SIPDispatchRule({\n        rule: {\n          case: 'dispatchRuleDirect',\n          value: new SIPDispatchRuleDirect({\n            roomName: rule.roomName,\n            pin: rule.pin || '',\n          }),\n        },\n      });\n    } else if (rule.type == 'individual') {\n      ruleProto = new SIPDispatchRule({\n        rule: {\n          case: 'dispatchRuleIndividual',\n          value: new SIPDispatchRuleIndividual({\n            roomPrefix: rule.roomPrefix,\n            pin: rule.pin || '',\n          }),\n        },\n      });\n    }\n\n    const req = new CreateSIPDispatchRuleRequest({\n      rule: ruleProto,\n      trunkIds: opts.trunkIds,\n      hidePhoneNumber: opts.hidePhoneNumber,\n      name: opts.name,\n      metadata: opts.metadata,\n      attributes: opts.attributes,\n      roomPreset: opts.roomPreset,\n      roomConfig: opts.roomConfig,\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'CreateSIPDispatchRule',\n      req,\n      await this.authHeader({}, { admin: true }),\n    );\n    return SIPDispatchRuleInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * Updates an existing SIP dispatch rule by replacing it entirely.\n   *\n   * @param sipDispatchRuleId - ID of the SIP dispatch rule to update\n   * @param rule - new SIP dispatch rule\n   * @returns Updated SIP dispatch rule\n   */\n  async updateSipDispatchRule(\n    sipDispatchRuleId: string,\n    rule: SIPDispatchRuleInfo,\n  ): Promise<SIPDispatchRuleInfo> {\n    const req = new UpdateSIPDispatchRuleRequest({\n      sipDispatchRuleId: sipDispatchRuleId,\n      action: {\n        case: 'replace',\n        value: rule,\n      },\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'UpdateSIPDispatchRule',\n      req,\n      await this.authHeader({}, { admin: true }),\n    );\n\n    return SIPDispatchRuleInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * Updates specific fields of an existing SIP dispatch rule.\n   * Only provided fields will be updated.\n   *\n   * @param sipDispatchRuleId - ID of the SIP dispatch rule to update\n   * @param fields - Fields of the dispatch rule to update\n   * @returns Updated SIP dispatch rule\n   */\n  async updateSipDispatchRuleFields(\n    sipDispatchRuleId: string,\n    fields: SipDispatchRuleUpdateOptions = {},\n  ): Promise<SIPDispatchRuleInfo> {\n    const req = new UpdateSIPDispatchRuleRequest({\n      sipDispatchRuleId: sipDispatchRuleId,\n      action: {\n        case: 'update',\n        value: fields,\n      },\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'UpdateSIPDispatchRule',\n      req,\n      await this.authHeader({}, { admin: true }),\n    );\n\n    return SIPDispatchRuleInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * Updates an existing SIP inbound trunk by replacing it entirely.\n   *\n   * @param sipTrunkId - ID of the SIP inbound trunk to update\n   * @param trunk - SIP inbound trunk to update with\n   * @returns Updated SIP inbound trunk\n   */\n  async updateSipInboundTrunk(\n    sipTrunkId: string,\n    trunk: SIPInboundTrunkInfo,\n  ): Promise<SIPInboundTrunkInfo> {\n    const req = new UpdateSIPInboundTrunkRequest({\n      sipTrunkId,\n      action: {\n        case: 'replace',\n        value: trunk,\n      },\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'UpdateSIPInboundTrunk',\n      req,\n      await this.authHeader({}, { admin: true }),\n    );\n\n    return SIPInboundTrunkInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * Updates specific fields of an existing SIP inbound trunk.\n   * Only provided fields will be updated.\n   *\n   * @param sipTrunkId - ID of the SIP inbound trunk to update\n   * @param fields - Fields of the inbound trunk to update\n   * @returns Updated SIP inbound trunk\n   */\n  async updateSipInboundTrunkFields(\n    sipTrunkId: string,\n    fields: SipInboundTrunkUpdateOptions,\n  ): Promise<SIPInboundTrunkInfo> {\n    const req = new UpdateSIPInboundTrunkRequest({\n      sipTrunkId,\n      action: {\n        case: 'update',\n        value: fields,\n      },\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'UpdateSIPInboundTrunk',\n      req,\n      await this.authHeader({}, { admin: true }),\n    );\n\n    return SIPInboundTrunkInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * Updates an existing SIP outbound trunk by replacing it entirely.\n   *\n   * @param sipTrunkId - ID of the SIP outbound trunk to update\n   * @param trunk - SIP outbound trunk to update with\n   * @returns Updated SIP outbound trunk\n   */\n  async updateSipOutboundTrunk(\n    sipTrunkId: string,\n    trunk: SIPOutboundTrunkInfo,\n  ): Promise<SIPOutboundTrunkInfo> {\n    const req = new UpdateSIPOutboundTrunkRequest({\n      sipTrunkId,\n      action: {\n        case: 'replace',\n        value: trunk,\n      },\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'UpdateSIPOutboundTrunk',\n      req,\n      await this.authHeader({}, { admin: true }),\n    );\n\n    return SIPOutboundTrunkInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * Updates specific fields of an existing SIP outbound trunk.\n   * Only provided fields will be updated.\n   *\n   * @param sipTrunkId - ID of the SIP outbound trunk to update\n   * @param fields - Fields of the outbound trunk to update\n   * @returns Updated SIP outbound trunk\n   */\n  async updateSipOutboundTrunkFields(\n    sipTrunkId: string,\n    fields: SipOutboundTrunkUpdateOptions,\n  ): Promise<SIPOutboundTrunkInfo> {\n    const req = new UpdateSIPOutboundTrunkRequest({\n      sipTrunkId,\n      action: {\n        case: 'update',\n        value: fields,\n      },\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'UpdateSIPOutboundTrunk',\n      req,\n      await this.authHeader({}, { admin: true }),\n    );\n\n    return SIPOutboundTrunkInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * List SIP dispatch rules with optional filtering.\n   *\n   * @param list - Request with optional filtering parameters\n   * @returns Response containing list of SIP dispatch rules\n   */\n  async listSipDispatchRule(\n    list: ListSipDispatchRuleOptions = {},\n  ): Promise<Array<SIPDispatchRuleInfo>> {\n    const req = new ListSIPDispatchRuleRequest(list).toJson();\n    const data = await this.rpc.request(\n      svc,\n      'ListSIPDispatchRule',\n      req,\n      await this.authHeader({}, { admin: true }),\n    );\n    return ListSIPDispatchRuleResponse.fromJson(data, { ignoreUnknownFields: true }).items ?? [];\n  }\n\n  /**\n   * Delete a SIP dispatch rule.\n   *\n   * @param sipDispatchRuleId - ID of the SIP dispatch rule to delete\n   * @returns Deleted rule information\n   */\n  async deleteSipDispatchRule(sipDispatchRuleId: string): Promise<SIPDispatchRuleInfo> {\n    const data = await this.rpc.request(\n      svc,\n      'DeleteSIPDispatchRule',\n      new DeleteSIPDispatchRuleRequest({ sipDispatchRuleId }).toJson(),\n      await this.authHeader({}, { admin: true }),\n    );\n    return SIPDispatchRuleInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * Create a new SIP participant.\n   *\n   * @param sipTrunkId - sip trunk to use for the call\n   * @param number - number to dial\n   * @param roomName - room to attach the call to\n   * @param opts - CreateSipParticipantOptions\n   * @returns Created SIP participant\n   */\n  async createSipParticipant(\n    sipTrunkId: string,\n    number: string,\n    roomName: string,\n    opts?: CreateSipParticipantOptions,\n  ): Promise<SIPParticipantInfo> {\n    if (opts === undefined) {\n      opts = {};\n    }\n\n    if (opts.timeout === undefined) {\n      opts.timeout = opts.waitUntilAnswered ? 60 : 10;\n    }\n\n    const req = new CreateSIPParticipantRequest({\n      sipTrunkId: sipTrunkId,\n      sipCallTo: number,\n      sipNumber: opts.fromNumber,\n      roomName: roomName,\n      participantIdentity: opts.participantIdentity || 'sip-participant',\n      participantName: opts.participantName,\n      displayName: opts.displayName,\n      participantMetadata: opts.participantMetadata,\n      participantAttributes: opts.participantAttributes,\n      dtmf: opts.dtmf,\n      playDialtone: opts.playDialtone ?? opts.playRingtone,\n      headers: opts.headers,\n      hidePhoneNumber: opts.hidePhoneNumber,\n      includeHeaders: opts.includeHeaders,\n      ringingTimeout: opts.ringingTimeout\n        ? new Duration({ seconds: BigInt(opts.ringingTimeout) })\n        : undefined,\n      maxCallDuration: opts.maxCallDuration\n        ? new Duration({ seconds: BigInt(opts.maxCallDuration) })\n        : undefined,\n      krispEnabled: opts.krispEnabled,\n      waitUntilAnswered: opts.waitUntilAnswered,\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'CreateSIPParticipant',\n      req,\n      await this.authHeader({}, { call: true }),\n      opts.timeout,\n    );\n    return SIPParticipantInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * Transfer a SIP participant to a different room.\n   *\n   * @param roomName - room the SIP participant to transfer is connectd to\n   * @param participantIdentity - identity of the SIP participant to transfer\n   * @param transferTo - SIP URL to transfer the participant to\n   * @param opts - TransferSipParticipantOptions\n   */\n  async transferSipParticipant(\n    roomName: string,\n    participantIdentity: string,\n    transferTo: string,\n    opts?: TransferSipParticipantOptions,\n  ): Promise<void> {\n    if (opts === undefined) {\n      opts = {};\n    }\n\n    const req = new TransferSIPParticipantRequest({\n      participantIdentity: participantIdentity,\n      roomName: roomName,\n      transferTo: transferTo,\n      playDialtone: opts.playDialtone,\n      headers: opts.headers,\n    }).toJson();\n\n    await this.rpc.request(\n      svc,\n      'TransferSIPParticipant',\n      req,\n      await this.authHeader({ roomAdmin: true, room: roomName }, { call: true }),\n    );\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1652, "column": 0}, "map": {"version":3,"sources":["file:///D:/uplift-demo/demo/node_modules/livekit-server-sdk/src/crypto/digest.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n// Use the Web Crypto API if available, otherwise fallback to Node.js crypto\nexport async function digest(data: string): Promise<ArrayBuffer> {\n  if (globalThis.crypto?.subtle) {\n    const encoder = new TextEncoder();\n    return crypto.subtle.digest('SHA-256', encoder.encode(data));\n  } else {\n    const nodeCrypto = await import('node:crypto');\n    return nodeCrypto.createHash('sha256').update(data).digest();\n  }\n}\n"],"names":[],"mappings":";;;;AAKA,eAAsB,OAAO,IAAA,EAAoC;IALjE,IAAA;IAME,IAAA,CAAI,KAAA,WAAW,MAAA,KAAX,OAAA,KAAA,IAAA,GAAmB,MAAA,EAAQ;QAC7B,MAAM,UAAU,IAAI,YAAY;QAChC,OAAO,OAAO,MAAA,CAAO,MAAA,CAAO,WAAW,QAAQ,MAAA,CAAO,IAAI,CAAC;IAC7D,OAAO;QACL,MAAM,aAAa,MAAM,OAAO,aAAa;QAC7C,OAAO,WAAW,UAAA,CAAW,QAAQ,EAAE,MAAA,CAAO,IAAI,EAAE,MAAA,CAAO;IAC7D;AACF","debugId":null}},
    {"offset": {"line": 1672, "column": 0}, "map": {"version":3,"sources":["file:///D:/uplift-demo/demo/node_modules/livekit-server-sdk/src/WebhookReceiver.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { BinaryReadOptions, JsonReadOptions, JsonValue } from '@bufbuild/protobuf';\nimport { WebhookEvent as ProtoWebhookEvent } from '@livekit/protocol';\nimport { TokenVerifier } from './AccessToken.js';\nimport { digest } from './crypto/digest.js';\n\nexport const authorizeHeader = 'Authorize';\n\nexport class WebhookEvent extends ProtoWebhookEvent {\n  event: WebhookEventNames = '';\n\n  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WebhookEvent {\n    return new WebhookEvent().fromBinary(bytes, options);\n  }\n\n  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WebhookEvent {\n    return new WebhookEvent().fromJson(jsonValue, options);\n  }\n\n  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WebhookEvent {\n    return new WebhookEvent().fromJsonString(jsonString, options);\n  }\n}\n\nexport type WebhookEventNames =\n  | 'room_started'\n  | 'room_finished'\n  | 'participant_joined'\n  | 'participant_left'\n  | 'participant_connection_aborted'\n  | 'track_published'\n  | 'track_unpublished'\n  | 'egress_started'\n  | 'egress_updated'\n  | 'egress_ended'\n  | 'ingress_started'\n  | 'ingress_ended'\n  /**\n   * @internal\n   * @remarks only used as a default value, not a valid webhook event\n   */\n  | '';\n\nexport class WebhookReceiver {\n  private verifier: TokenVerifier;\n\n  constructor(apiKey: string, apiSecret: string) {\n    this.verifier = new TokenVerifier(apiKey, apiSecret);\n  }\n\n  /**\n   * @param body - string of the posted body\n   * @param authHeader - `Authorization` header from the request\n   * @param skipAuth - true to skip auth validation\n   * @param clockTolerance - How much tolerance to allow for checks against the auth header to be skewed from the claims\n   * @returns The processed webhook event\n   */\n  async receive(\n    body: string,\n    authHeader?: string,\n    skipAuth: boolean = false,\n    clockTolerance?: string | number,\n  ): Promise<WebhookEvent> {\n    // verify token\n    if (!skipAuth) {\n      if (!authHeader) {\n        throw new Error('authorization header is empty');\n      }\n      const claims = await this.verifier.verify(authHeader, clockTolerance);\n      // confirm sha\n      const hash = await digest(body);\n      const hashDecoded = btoa(\n        Array.from(new Uint8Array(hash))\n          .map((v) => String.fromCharCode(v))\n          .join(''),\n      );\n\n      if (claims.sha256 !== hashDecoded) {\n        throw new Error('sha256 checksum of body does not match');\n      }\n    }\n\n    return WebhookEvent.fromJson(JSON.parse(body), { ignoreUnknownFields: true });\n  }\n}\n"],"names":[],"mappings":";;;;;;;;AAIA,SAAS,gBAAgB,yBAAyB;AAClD,SAAS,qBAAqB;AAC9B,SAAS,cAAc;;;;AAEhB,MAAM,kBAAkB;AAExB,MAAM,qBAAqB,yLAAA,CAAkB;IAA7C,aAAA;QAAA,KAAA,IAAA;QACL,IAAA,CAAA,KAAA,GAA2B;IAAA;IAE3B,OAAO,WAAW,KAAA,EAAmB,OAAA,EAAoD;QACvF,OAAO,IAAI,aAAa,EAAE,UAAA,CAAW,OAAO,OAAO;IACrD;IAEA,OAAO,SAAS,SAAA,EAAsB,OAAA,EAAkD;QACtF,OAAO,IAAI,aAAa,EAAE,QAAA,CAAS,WAAW,OAAO;IACvD;IAEA,OAAO,eAAe,UAAA,EAAoB,OAAA,EAAkD;QAC1F,OAAO,IAAI,aAAa,EAAE,cAAA,CAAe,YAAY,OAAO;IAC9D;AACF;AAqBO,MAAM,gBAAgB;IAG3B,YAAY,MAAA,EAAgB,SAAA,CAAmB;QAC7C,IAAA,CAAK,QAAA,GAAW,IAAI,kLAAA,CAAc,QAAQ,SAAS;IACrD;IAAA;;;;;;GAAA,GASA,MAAM,QACJ,IAAA,EACA,UAAA,EACA,WAAoB,KAAA,EACpB,cAAA,EACuB;QAEvB,IAAI,CAAC,UAAU;YACb,IAAI,CAAC,YAAY;gBACf,MAAM,IAAI,MAAM,+BAA+B;YACjD;YACA,MAAM,SAAS,MAAM,IAAA,CAAK,QAAA,CAAS,MAAA,CAAO,YAAY,cAAc;YAEpE,MAAM,OAAO,UAAM,gLAAA,EAAO,IAAI;YAC9B,MAAM,cAAc,KAClB,MAAM,IAAA,CAAK,IAAI,WAAW,IAAI,CAAC,EAC5B,GAAA,CAAI,CAAC,IAAM,OAAO,YAAA,CAAa,CAAC,CAAC,EACjC,IAAA,CAAK,EAAE;YAGZ,IAAI,OAAO,MAAA,KAAW,aAAa;gBACjC,MAAM,IAAI,MAAM,wCAAwC;YAC1D;QACF;QAEA,OAAO,aAAa,QAAA,CAAS,KAAK,KAAA,CAAM,IAAI,GAAG;YAAE,qBAAqB;QAAK,CAAC;IAC9E;AACF","debugId":null}},
    {"offset": {"line": 1735, "column": 0}, "map": {"version":3,"sources":["file:///D:/uplift-demo/demo/node_modules/livekit-server-sdk/src/index.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\n\nexport {\n  AliOSSUpload,\n  AudioCodec,\n  AutoParticipantEgress,\n  AutoTrackEgress,\n  AzureBlobUpload,\n  DataPacket_Kind,\n  DirectFileOutput,\n  EgressInfo,\n  EgressStatus,\n  EncodedFileOutput,\n  EncodedFileType,\n  EncodingOptions,\n  EncodingOptionsPreset,\n  GCPUpload,\n  ImageCodec,\n  ImageFileSuffix,\n  ImageOutput,\n  IngressAudioEncodingOptions,\n  IngressAudioEncodingPreset,\n  IngressAudioOptions,\n  IngressInfo,\n  IngressInput,\n  IngressState,\n  IngressVideoEncodingOptions,\n  IngressVideoEncodingPreset,\n  IngressVideoOptions,\n  ParticipantEgressRequest,\n  ParticipantInfo,\n  ParticipantInfo_State,\n  ParticipantPermission,\n  Room,\n  RoomAgentDispatch,\n  RoomCompositeEgressRequest,\n  RoomEgress,\n  S3Upload,\n  SIPDispatchRuleInfo,\n  SIPParticipantInfo,\n  SIPTrunkInfo,\n  SegmentedFileOutput,\n  SegmentedFileProtocol,\n  StreamOutput,\n  StreamProtocol,\n  TrackCompositeEgressRequest,\n  TrackEgressRequest,\n  TrackInfo,\n  TrackSource,\n  TrackType,\n  WebEgressRequest,\n  VideoCodec,\n  WebhookConfig,\n} from '@livekit/protocol';\nexport * from './AccessToken.js';\nexport * from './AgentDispatchClient.js';\nexport * from './EgressClient.js';\nexport * from './grants.js';\nexport * from './IngressClient.js';\nexport * from './RoomServiceClient.js';\nexport * from './SipClient.js';\nexport * from './WebhookReceiver.js';\n"],"names":[],"mappings":";AAIA;AAoDA,cAAc;AACd,cAAc;AACd,cAAc;AACd,cAAc;AACd,cAAc;AACd,cAAc;AACd,cAAc;AACd,cAAc","debugId":null}}]
}